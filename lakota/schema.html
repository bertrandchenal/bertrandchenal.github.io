<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lakota.schema API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lakota.schema</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import shlex
from dataclasses import dataclass

from numcodecs import registry
from numpy import asarray, ascontiguousarray, dtype, frombuffer, issubdtype, ndarray

DTYPES = [dtype(s) for s in (&#34;datetime64[s]&#34;, &#34;int64&#34;, &#34;float64&#34;, &#34;U&#34;, &#34;O&#34;)]

ALIASES = {
    &#34;timestamp&#34;: &#34;M8[s]&#34;,
    &#34;float&#34;: &#34;f8&#34;,
    &#34;int&#34;: &#34;i8&#34;,
    &#34;str&#34;: &#34;U&#34;,
}

__all__ = [&#34;Schema&#34;]


class Codec:
    def __init__(self, dt, *codec_names):
        # Make sure dtype is valid
        dt = dtype(ALIASES.get(dt, dt))
        for base_type in DTYPES:
            if issubdtype(dt, base_type):
                dt = base_type
                break
        else:
            raise ValueError(f&#34;Column type &#39;{dt}&#39; not supported&#34;)
        self.dt = dt
        # Build list of codecs
        if codec_names:
            self.codec_names = codec_names
        else:
            # Adapt dtypes and codec_names
            default_codec_names = [&#34;blosc&#34;]
            if dt in (dtype(&#34;O&#34;), dtype(&#34;U&#34;)):
                default_codec_names = [&#34;msgpack2&#34;, &#34;zstd&#34;]
            self.codec_names = default_codec_names

    def encode(self, arr):
        if len(arr) == 0:
            return b&#34;&#34;
        # encoding may require contiguous memory
        arr = ascontiguousarray(arr)
        # convert to proper type
        arr = arr.astype(self.dt)
        # Apply codecs
        for codec_name in self.codec_names:
            codec = registry.codec_registry[codec_name]
            arr = codec().encode(arr)
        return arr

    def decode(self, arr):
        if len(arr) == 0:
            return asarray([], dtype=self.dt)
        # Apply all codecs
        for name in reversed(self.codec_names):
            codec = registry.codec_registry[name]
            arr = codec().decode(arr)
        if self.dt in (&#34;O&#34;, &#34;U&#34;):
            return arr.astype(self.dt)
        return frombuffer(arr, dtype=self.dt)

    def __eq__(self, other):
        return self.codec_names == other.codec_names and self.dt == other.dt

    def __repr__(self):
        names = &#34;, &#34;.join(self.codec_names)
        return f&#34;&lt;Codec {self.dt}:{names}&gt;&#34;


class SchemaColumn:
    def __init__(self, name, dt, codecs, idx):
        self.name = name
        self.codec = Codec(dt, *codecs)
        self.idx = idx

    @classmethod
    def from_ui(cls, name, definition):
        parser = shlex.shlex(definition, posix=True, punctuation_chars=&#34;|*&#34;)
        parser.wordchars += &#34;[]&#34;
        dt, *tokens = parser
        idx = False
        codec_names = []
        state = None
        for tk in tokens:
            if tk == &#34;|&#34;:
                state = &#34;codec&#34;
            elif tk == &#34;*&#34;:
                idx = True
            elif state == &#34;codec&#34;:
                codec_names.append(tk)
            else:
                raise ValueError(f&#34;Unexpected item: {tk}&#34;)
        return SchemaColumn(name, dt, codecs=codec_names, idx=idx)

    def cast(self, arr):
        if isinstance(arr, ndarray) and issubdtype(arr.dtype, self.codec.dt):
            return arr
        return asarray(arr, dtype=self.codec.dt)

    def cast_scalar(self, value):
        return dtype(self.codec.dt).type(value)

    def dump(self):
        return {
            &#34;dt&#34;: str(self.codec.dt),
            &#34;codecs&#34;: self.codec.codec_names,
            &#34;idx&#34;: self.idx,
        }

    def __eq__(self, other):
        return (
            self.name == other.name
            and self.idx == other.idx
            and self.codec == other.codec
        )


class Schema:
    def __init__(self, **columns):
        self.kind = None
        self.columns = {}
        for name, definition in columns.items():
            if not isinstance(definition, SchemaColumn):
                definition = SchemaColumn.from_ui(name, definition)
            self.columns[name] = definition

        self.idx = {n: c for n, c in self.columns.items() if c.idx}
        self.non_idx = {n: c for n, c in self.columns.items() if not c.idx}
        if len(self.idx) == 0:
            raise ValueError(&#34;Invalid schema, no index defined&#34;)

    @classmethod
    def kv(cls, **columns):
        schema = Schema(**columns)
        schema.kind = &#34;kv&#34;
        return schema

    @classmethod
    def from_frame(cls, frame, idx_columns=None):
        &#34;&#34;&#34;
        Instantiate a schema based on the column names and type if the given frame (a dict or a dataframe)
        &#34;&#34;&#34;
        idx_columns = idx_columns or list(frame)
        col_defs = {}
        for name in frame:
            arr = frame[name]
            col_defs[name] = SchemaColumn(name, arr.dtype, [], name in idx_columns)
        return Schema(**col_defs)

    def serialize(self, values):
        if not values:
            return tuple()
        if not isinstance(values, (list, tuple)):
            values = (values,)
        # TODO implement column type based repr
        return tuple(str(val) for col, val in zip(self.columns.values(), values))

    def deserialize(self, values=tuple()):
        if not values:
            return tuple()
        if not isinstance(values, (list, tuple)):
            values = (values,)
        res = tuple(
            col.cast_scalar(val) for col, val in zip(self.columns.values(), values)
        )
        return res

    @classmethod
    def loads(self, data):
        columns = {
            name: SchemaColumn(name, **opts) for name, opts in data[&#34;columns&#34;].items()
        }
        if data[&#34;kind&#34;] == &#34;kv&#34;:
            return Schema.kv(**columns)
        return Schema(**columns)

    def dump(self):
        columns = {c.name: c.dump() for c in self.columns.values()}
        return {&#34;kind&#34;: self.kind, &#34;columns&#34;: columns}

    def __iter__(self):
        return iter(self.columns.keys())

    def __repr__(self):
        cols = [f&#34;{c.name} {c.codec.dt}&#34; for c in self.columns.values()]
        return &#34;&lt;Schema {}&gt;&#34;.format(&#34; &#34;.join(cols))

    def __eq__(self, other):
        return all(
            x == y for x, y in zip(self.columns.values(), other.columns.values())
        )

    def cast(self, df=None):
        if df is None:
            df = {}
            columns = list(self)
        else:
            columns = [c for c in df if c in self]

        res = {}
        for name in columns:
            col = self[name]
            res[col.name] = col.cast(df.get(col.name, []))
        return res

    def __getitem__(self, name):
        return self.columns[name]

    def row(self, df, pos, full=True):
        &#34;&#34;&#34;
        Extract a row of the dataframe-like object at
        given position
        &#34;&#34;&#34;
        cols = self.columns if full else self.idx
        return tuple(df[n][pos] for n in cols)

    def __matmul__(self, labels):
        if not isinstance(labels, (list, tuple)):
            labels = [labels]
        return SeriesDefinition(self, labels)


@dataclass
class SeriesDefinition:
    schema: Schema
    labels: list</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lakota.schema.Schema"><code class="flex name class">
<span>class <span class="ident">Schema</span></span>
<span>(</span><span>**columns)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Schema:
    def __init__(self, **columns):
        self.kind = None
        self.columns = {}
        for name, definition in columns.items():
            if not isinstance(definition, SchemaColumn):
                definition = SchemaColumn.from_ui(name, definition)
            self.columns[name] = definition

        self.idx = {n: c for n, c in self.columns.items() if c.idx}
        self.non_idx = {n: c for n, c in self.columns.items() if not c.idx}
        if len(self.idx) == 0:
            raise ValueError(&#34;Invalid schema, no index defined&#34;)

    @classmethod
    def kv(cls, **columns):
        schema = Schema(**columns)
        schema.kind = &#34;kv&#34;
        return schema

    @classmethod
    def from_frame(cls, frame, idx_columns=None):
        &#34;&#34;&#34;
        Instantiate a schema based on the column names and type if the given frame (a dict or a dataframe)
        &#34;&#34;&#34;
        idx_columns = idx_columns or list(frame)
        col_defs = {}
        for name in frame:
            arr = frame[name]
            col_defs[name] = SchemaColumn(name, arr.dtype, [], name in idx_columns)
        return Schema(**col_defs)

    def serialize(self, values):
        if not values:
            return tuple()
        if not isinstance(values, (list, tuple)):
            values = (values,)
        # TODO implement column type based repr
        return tuple(str(val) for col, val in zip(self.columns.values(), values))

    def deserialize(self, values=tuple()):
        if not values:
            return tuple()
        if not isinstance(values, (list, tuple)):
            values = (values,)
        res = tuple(
            col.cast_scalar(val) for col, val in zip(self.columns.values(), values)
        )
        return res

    @classmethod
    def loads(self, data):
        columns = {
            name: SchemaColumn(name, **opts) for name, opts in data[&#34;columns&#34;].items()
        }
        if data[&#34;kind&#34;] == &#34;kv&#34;:
            return Schema.kv(**columns)
        return Schema(**columns)

    def dump(self):
        columns = {c.name: c.dump() for c in self.columns.values()}
        return {&#34;kind&#34;: self.kind, &#34;columns&#34;: columns}

    def __iter__(self):
        return iter(self.columns.keys())

    def __repr__(self):
        cols = [f&#34;{c.name} {c.codec.dt}&#34; for c in self.columns.values()]
        return &#34;&lt;Schema {}&gt;&#34;.format(&#34; &#34;.join(cols))

    def __eq__(self, other):
        return all(
            x == y for x, y in zip(self.columns.values(), other.columns.values())
        )

    def cast(self, df=None):
        if df is None:
            df = {}
            columns = list(self)
        else:
            columns = [c for c in df if c in self]

        res = {}
        for name in columns:
            col = self[name]
            res[col.name] = col.cast(df.get(col.name, []))
        return res

    def __getitem__(self, name):
        return self.columns[name]

    def row(self, df, pos, full=True):
        &#34;&#34;&#34;
        Extract a row of the dataframe-like object at
        given position
        &#34;&#34;&#34;
        cols = self.columns if full else self.idx
        return tuple(df[n][pos] for n in cols)

    def __matmul__(self, labels):
        if not isinstance(labels, (list, tuple)):
            labels = [labels]
        return SeriesDefinition(self, labels)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="lakota.schema.Schema.from_frame"><code class="name flex">
<span>def <span class="ident">from_frame</span></span>(<span>frame, idx_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiate a schema based on the column names and type if the given frame (a dict or a dataframe)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_frame(cls, frame, idx_columns=None):
    &#34;&#34;&#34;
    Instantiate a schema based on the column names and type if the given frame (a dict or a dataframe)
    &#34;&#34;&#34;
    idx_columns = idx_columns or list(frame)
    col_defs = {}
    for name in frame:
        arr = frame[name]
        col_defs[name] = SchemaColumn(name, arr.dtype, [], name in idx_columns)
    return Schema(**col_defs)</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.kv"><code class="name flex">
<span>def <span class="ident">kv</span></span>(<span>**columns)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def kv(cls, **columns):
    schema = Schema(**columns)
    schema.kind = &#34;kv&#34;
    return schema</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def loads(self, data):
    columns = {
        name: SchemaColumn(name, **opts) for name, opts in data[&#34;columns&#34;].items()
    }
    if data[&#34;kind&#34;] == &#34;kv&#34;:
        return Schema.kv(**columns)
    return Schema(**columns)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.schema.Schema.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>self, df=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cast(self, df=None):
    if df is None:
        df = {}
        columns = list(self)
    else:
        columns = [c for c in df if c in self]

    res = {}
    for name in columns:
        col = self[name]
        res[col.name] = col.cast(df.get(col.name, []))
    return res</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, values=())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, values=tuple()):
    if not values:
        return tuple()
    if not isinstance(values, (list, tuple)):
        values = (values,)
    res = tuple(
        col.cast_scalar(val) for col, val in zip(self.columns.values(), values)
    )
    return res</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self):
    columns = {c.name: c.dump() for c in self.columns.values()}
    return {&#34;kind&#34;: self.kind, &#34;columns&#34;: columns}</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>self, df, pos, full=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a row of the dataframe-like object at
given position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row(self, df, pos, full=True):
    &#34;&#34;&#34;
    Extract a row of the dataframe-like object at
    given position
    &#34;&#34;&#34;
    cols = self.columns if full else self.idx
    return tuple(df[n][pos] for n in cols)</code></pre>
</details>
</dd>
<dt id="lakota.schema.Schema.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, values):
    if not values:
        return tuple()
    if not isinstance(values, (list, tuple)):
        values = (values,)
    # TODO implement column type based repr
    return tuple(str(val) for col, val in zip(self.columns.values(), values))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lakota" href="index.html">lakota</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lakota.schema.Schema" href="#lakota.schema.Schema">Schema</a></code></h4>
<ul class="two-column">
<li><code><a title="lakota.schema.Schema.cast" href="#lakota.schema.Schema.cast">cast</a></code></li>
<li><code><a title="lakota.schema.Schema.deserialize" href="#lakota.schema.Schema.deserialize">deserialize</a></code></li>
<li><code><a title="lakota.schema.Schema.dump" href="#lakota.schema.Schema.dump">dump</a></code></li>
<li><code><a title="lakota.schema.Schema.from_frame" href="#lakota.schema.Schema.from_frame">from_frame</a></code></li>
<li><code><a title="lakota.schema.Schema.kv" href="#lakota.schema.Schema.kv">kv</a></code></li>
<li><code><a title="lakota.schema.Schema.loads" href="#lakota.schema.Schema.loads">loads</a></code></li>
<li><code><a title="lakota.schema.Schema.row" href="#lakota.schema.Schema.row">row</a></code></li>
<li><code><a title="lakota.schema.Schema.serialize" href="#lakota.schema.Schema.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>