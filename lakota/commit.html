<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lakota.commit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lakota.commit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from threading import Lock

from numcodecs import registry
from numpy import asarray, concatenate, isin, where

from .frame import Frame
from .schema import Codec, Schema
from .utils import hashed_path

__all__ = [&#39;Commit&#39;, &#39;Segment&#39;]

class Commit:

    digest_codec = Codec(&#34;U&#34;)  # FIXME use better encoding
    len_codec = Codec(&#34;int&#34;)
    label_codec = Codec(&#34;str&#34;)
    closed_codec = Codec(&#34;str&#34;)  # Could be i1

    def __init__(self, schema, label, start, stop, digest, length, closed):
        assert list(digest) == list(schema)
        self.schema = schema
        self.label = label  # Array of str
        self.start = start  # Dict of Arrays
        self.stop = stop  # Dict of arrays
        self.digest = digest  # Dict of arrays
        self.length = length  # Array of int
        self.closed = closed  # Array of (&#34;l&#34;, &#34;r&#34;, &#34;b&#34;, None)

    @classmethod
    def one(cls, schema, label, start, stop, digest, length, closed=&#34;both&#34;):
        label = asarray([label])
        start = dict(zip(schema.idx, (asarray([s]) for s in start)))
        stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
        digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
        length = [length]
        closed = [closed]
        return Commit(schema, label, start, stop, digest, length, closed)

    @classmethod
    def decode(cls, schema, payload):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = msgpck.decode(payload)[0]
        values = {}
        # Decode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            key_vals = {}
            columns = schema if key == &#34;digest&#34; else schema.idx
            for name in columns:
                codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
                key_vals[name] = codec.decode(data[key][name])
            values[key] = key_vals

        # Decode len and labels
        values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
        values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
        values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])
        return Commit(schema, **values)

    def encode(self):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = {}
        # Encode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            key_vals = {}
            for pos, name in enumerate(columns):
                codec = (
                    self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
                )
                arr = getattr(self, key)[name]
                key_vals[name] = codec.encode(arr)
            data[key] = key_vals

        # Encode digests
        for name in self.schema:
            data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

        # Encode length, closed and labels
        data[&#34;length&#34;] = self.len_codec.encode(self.length)
        data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
        data[&#34;label&#34;] = self.label_codec.encode(self.label)
        return msgpck.encode([data])

    def split(self, label, start, stop):
        start_values = {&#34;_label&#34;: self.label}
        start_values.update(self.start)
        stop_values = {&#34;_label&#34;: self.label}
        stop_values.update(self.stop)
        frm_start = Frame(Schema.from_frame(start_values), start_values)
        frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
        start_pos = frm_stop.index((label,) + start, right=True)
        stop_pos = frm_start.index((label,) + stop, right=False)
        return start_pos, stop_pos

    def __len__(self):
        return len(self.label)

    def at(self, pos):
        if pos &lt; 0:
            pos = len(self) + pos
        res = {}
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            values = getattr(self, key)
            res[key] = tuple(values[n][pos] for n in columns)

        for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
            res[key] = getattr(self, key)[pos]
        return res

    def update(self, label, start, stop, digest, length, closed=&#34;both&#34;):
        if not start &lt;= stop:
            raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
        inner = Commit.one(self.schema, label, start, stop, digest, length, closed)
        if len(self) == 0:
            return inner

        first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
        last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
        if (label, start) &lt;= first and (label, stop) &gt;= last:
            return inner

        start_pos, stop_pos = self.split(label, start, stop)
        # Corner case: we hit right in the middle of an existing row
        if start_pos + 1 == stop_pos:
            row = self.at(start_pos)
            if label == row[&#34;start&#34;] and row[&#34;start&#34;] &lt; start and stop &lt; row[&#34;stop&#34;]:
                start_row = row
                start_row[&#34;stop&#34;] = start
                start_row[&#34;closed&#34;] = (
                    &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
                )
                stop_row = self.at(start_pos)
                stop_row[&#34;start&#34;] = stop
                stop_row[&#34;closed&#34;] = (
                    &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
                )
                ci = Commit.concat(
                    self.head(start_pos),
                    Commit.one(schema=self.schema, **start_row),
                    inner,
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
                return ci

        # Truncate start_pos row
        head = None
        if start_pos &lt; len(self):
            start_row = self.at(start_pos)
            if (
                label == start_row[&#34;label&#34;]
                and start_row[&#34;start&#34;] &lt; start &lt;= start_row[&#34;stop&#34;]
            ):
                # We hit the right of an existing row
                start_row[&#34;stop&#34;] = start
                # XXX adapt behaviour if current update is not closed==both
                start_row[&#34;closed&#34;] = (
                    &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
                )
                if start_row[&#34;start&#34;] &lt; start_row[&#34;stop&#34;]:
                    head = Commit.concat(
                        self.head(start_pos),
                        Commit.one(schema=self.schema, **start_row),
                    )
                # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
                # start_row stop and start are both &#34;overshadowed&#34; by
                # new commit
        if head is None:
            head = self.head(start_pos)

        # Truncate stop_pos row
        tail = None
        stop_row = self.at(stop_pos - 1)
        if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt; stop_row[&#34;stop&#34;]:
            # We hit the left of an existing row
            stop_row[&#34;start&#34;] = stop
            # XXX adapt behavoour if current update is not closed==both
            stop_row[&#34;closed&#34;] = (
                &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
            )
            if stop_row[&#34;start&#34;] &lt; stop_row[&#34;stop&#34;]:
                tail = Commit.concat(
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
            # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
            # stop_row stop and start are both &#34;overshadowed&#34; by
            # new commit
        if tail is None:
            tail = self.tail(stop_pos)

        return Commit.concat(head, inner, tail)

    def slice(self, *pos):
        slc = slice(*pos)
        schema = self.schema
        start = {name: self.start[name][slc] for name in schema.idx}
        stop = {name: self.stop[name][slc] for name in schema.idx}
        digest = {name: self.digest[name][slc] for name in schema}
        label = self.label[slc]
        length = self.length[slc]
        closed = self.closed[slc]
        return Commit(schema, label, start, stop, digest, length, closed)

    def head(self, pos):
        return self.slice(None, pos)

    def tail(self, pos):
        return self.slice(pos, None)

    @classmethod
    def concat(cls, commit, *other_commits):
        schema = commit.schema
        all_ci = (commit,) + other_commits
        all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

        # Make sure there are no overlaps
        for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
            prv_tail = prv.at(-1)
            nxt_head = nxt.at(0)
            assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
                nxt_head[&#34;label&#34;],
                nxt_head[&#34;start&#34;],
            )

        start = {
            name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
        }
        stop = {
            name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
        }
        digest = {
            name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
        }
        label = concatenate([ci.label for ci in all_ci])
        length = concatenate([ci.length for ci in all_ci])
        closed = concatenate([ci.closed for ci in all_ci])

        return Commit(schema, label, start, stop, digest, length, closed)

    def __repr__(self):
        fmt = lambda a: &#34;/&#34;.join(map(str, a))
        starts = list(map(fmt, zip(*self.start.values())))
        stops = list(map(fmt, zip(*self.stop.values())))
        items = &#34;\n        &#34;.join(
            f&#34;{l}[{a} -&gt; {b}]&#34; for l, a, b in zip(self.label, starts, stops)
        )
        return f&#34;&lt;Commit {items}&gt;&#34;

    def segments(self, label, pod, start=None, stop=None):
        res = []
        (matches,) = where(self.label == label)
        for pos in matches:
            arr_start = tuple(arr[pos] for arr in self.start.values())
            arr_stop = tuple(arr[pos] for arr in self.stop.values())
            if start and start &gt; arr_stop:
                continue
            if stop and stop &lt; arr_start:
                continue

            digest = [arr[pos] for arr in self.digest.values()]
            closed = self.closed[pos]

            sgm = Segment(
                self.schema,
                pod,
                digest,
                start=max(arr_start, start) if start else arr_start,
                stop=min(arr_stop, stop) if stop else arr_stop,
                closed=closed,
            )
            res.append(sgm)
        return res

    def delete_labels(self, rm_labels):
        keep = ~isin(self.label, rm_labels)
        return Commit(
            schema=self.schema,
            label=self.label[keep],
            start={k: v[keep] for k, v in self.start.items()},
            stop={k: v[keep] for k, v in self.stop.items()},
            digest={k: v[keep] for k, v in self.digest.items()},
            length=self.length[keep],
            closed=self.closed[keep],
        )

    def __contains__(self, row):
        start_pos, _ = self.split(row[&#34;label&#34;], row[&#34;start&#34;], row[&#34;stop&#34;])
        if start_pos &gt;= len(self):
            return False
        match_row = self.at(start_pos)
        for attr in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            if match_row[attr] != row[attr]:
                return False
        return True


class Segment:
    def __init__(self, schema, pod, digests, start, stop, closed):
        self.schema = schema
        self.pod = pod
        self.start = start
        self.stop = stop
        self.closed = closed
        self.digest = dict(zip(schema, digests))
        self._frm = None
        self.start_pos = None
        self.stop_pos = None
        self.lock = Lock()

    def __len__(self):
        return len(self.frame)

    def read(self, name, start=None, stop=None):
        if not name in self.frame:
            self.frame[name] = self._read(name)
        return self.frame[name][start:stop]

    def _read(self, name):
        folder, filename = hashed_path(self.digest[name])
        payload = self.pod.cd(folder).read(filename)
        # TODO check payload checksum
        arr = self.schema[name].codec.decode(payload)
        return arr[self.start_pos : self.stop_pos]

    @property
    def frame(self):
        # Use a Frame instance as container to cache columns
        with self.lock:
            if self._frm is not None:
                return self._frm

            cols = {}
            for name in self.schema.idx:
                cols[name] = self._read(name)
            frm = Frame(self.schema, cols)
            self.start_pos, self.stop_pos = frm.index_slice(
                self.start, self.stop, closed=self.closed
            )
            self._frm = frm.slice(self.start_pos, self.stop_pos)
            return frm</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lakota.commit.Commit"><code class="flex name class">
<span>class <span class="ident">Commit</span></span>
<span>(</span><span>schema, label, start, stop, digest, length, closed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Commit:

    digest_codec = Codec(&#34;U&#34;)  # FIXME use better encoding
    len_codec = Codec(&#34;int&#34;)
    label_codec = Codec(&#34;str&#34;)
    closed_codec = Codec(&#34;str&#34;)  # Could be i1

    def __init__(self, schema, label, start, stop, digest, length, closed):
        assert list(digest) == list(schema)
        self.schema = schema
        self.label = label  # Array of str
        self.start = start  # Dict of Arrays
        self.stop = stop  # Dict of arrays
        self.digest = digest  # Dict of arrays
        self.length = length  # Array of int
        self.closed = closed  # Array of (&#34;l&#34;, &#34;r&#34;, &#34;b&#34;, None)

    @classmethod
    def one(cls, schema, label, start, stop, digest, length, closed=&#34;both&#34;):
        label = asarray([label])
        start = dict(zip(schema.idx, (asarray([s]) for s in start)))
        stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
        digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
        length = [length]
        closed = [closed]
        return Commit(schema, label, start, stop, digest, length, closed)

    @classmethod
    def decode(cls, schema, payload):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = msgpck.decode(payload)[0]
        values = {}
        # Decode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            key_vals = {}
            columns = schema if key == &#34;digest&#34; else schema.idx
            for name in columns:
                codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
                key_vals[name] = codec.decode(data[key][name])
            values[key] = key_vals

        # Decode len and labels
        values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
        values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
        values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])
        return Commit(schema, **values)

    def encode(self):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = {}
        # Encode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            key_vals = {}
            for pos, name in enumerate(columns):
                codec = (
                    self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
                )
                arr = getattr(self, key)[name]
                key_vals[name] = codec.encode(arr)
            data[key] = key_vals

        # Encode digests
        for name in self.schema:
            data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

        # Encode length, closed and labels
        data[&#34;length&#34;] = self.len_codec.encode(self.length)
        data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
        data[&#34;label&#34;] = self.label_codec.encode(self.label)
        return msgpck.encode([data])

    def split(self, label, start, stop):
        start_values = {&#34;_label&#34;: self.label}
        start_values.update(self.start)
        stop_values = {&#34;_label&#34;: self.label}
        stop_values.update(self.stop)
        frm_start = Frame(Schema.from_frame(start_values), start_values)
        frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
        start_pos = frm_stop.index((label,) + start, right=True)
        stop_pos = frm_start.index((label,) + stop, right=False)
        return start_pos, stop_pos

    def __len__(self):
        return len(self.label)

    def at(self, pos):
        if pos &lt; 0:
            pos = len(self) + pos
        res = {}
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            values = getattr(self, key)
            res[key] = tuple(values[n][pos] for n in columns)

        for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
            res[key] = getattr(self, key)[pos]
        return res

    def update(self, label, start, stop, digest, length, closed=&#34;both&#34;):
        if not start &lt;= stop:
            raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
        inner = Commit.one(self.schema, label, start, stop, digest, length, closed)
        if len(self) == 0:
            return inner

        first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
        last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
        if (label, start) &lt;= first and (label, stop) &gt;= last:
            return inner

        start_pos, stop_pos = self.split(label, start, stop)
        # Corner case: we hit right in the middle of an existing row
        if start_pos + 1 == stop_pos:
            row = self.at(start_pos)
            if label == row[&#34;start&#34;] and row[&#34;start&#34;] &lt; start and stop &lt; row[&#34;stop&#34;]:
                start_row = row
                start_row[&#34;stop&#34;] = start
                start_row[&#34;closed&#34;] = (
                    &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
                )
                stop_row = self.at(start_pos)
                stop_row[&#34;start&#34;] = stop
                stop_row[&#34;closed&#34;] = (
                    &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
                )
                ci = Commit.concat(
                    self.head(start_pos),
                    Commit.one(schema=self.schema, **start_row),
                    inner,
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
                return ci

        # Truncate start_pos row
        head = None
        if start_pos &lt; len(self):
            start_row = self.at(start_pos)
            if (
                label == start_row[&#34;label&#34;]
                and start_row[&#34;start&#34;] &lt; start &lt;= start_row[&#34;stop&#34;]
            ):
                # We hit the right of an existing row
                start_row[&#34;stop&#34;] = start
                # XXX adapt behaviour if current update is not closed==both
                start_row[&#34;closed&#34;] = (
                    &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
                )
                if start_row[&#34;start&#34;] &lt; start_row[&#34;stop&#34;]:
                    head = Commit.concat(
                        self.head(start_pos),
                        Commit.one(schema=self.schema, **start_row),
                    )
                # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
                # start_row stop and start are both &#34;overshadowed&#34; by
                # new commit
        if head is None:
            head = self.head(start_pos)

        # Truncate stop_pos row
        tail = None
        stop_row = self.at(stop_pos - 1)
        if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt; stop_row[&#34;stop&#34;]:
            # We hit the left of an existing row
            stop_row[&#34;start&#34;] = stop
            # XXX adapt behavoour if current update is not closed==both
            stop_row[&#34;closed&#34;] = (
                &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
            )
            if stop_row[&#34;start&#34;] &lt; stop_row[&#34;stop&#34;]:
                tail = Commit.concat(
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
            # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
            # stop_row stop and start are both &#34;overshadowed&#34; by
            # new commit
        if tail is None:
            tail = self.tail(stop_pos)

        return Commit.concat(head, inner, tail)

    def slice(self, *pos):
        slc = slice(*pos)
        schema = self.schema
        start = {name: self.start[name][slc] for name in schema.idx}
        stop = {name: self.stop[name][slc] for name in schema.idx}
        digest = {name: self.digest[name][slc] for name in schema}
        label = self.label[slc]
        length = self.length[slc]
        closed = self.closed[slc]
        return Commit(schema, label, start, stop, digest, length, closed)

    def head(self, pos):
        return self.slice(None, pos)

    def tail(self, pos):
        return self.slice(pos, None)

    @classmethod
    def concat(cls, commit, *other_commits):
        schema = commit.schema
        all_ci = (commit,) + other_commits
        all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

        # Make sure there are no overlaps
        for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
            prv_tail = prv.at(-1)
            nxt_head = nxt.at(0)
            assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
                nxt_head[&#34;label&#34;],
                nxt_head[&#34;start&#34;],
            )

        start = {
            name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
        }
        stop = {
            name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
        }
        digest = {
            name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
        }
        label = concatenate([ci.label for ci in all_ci])
        length = concatenate([ci.length for ci in all_ci])
        closed = concatenate([ci.closed for ci in all_ci])

        return Commit(schema, label, start, stop, digest, length, closed)

    def __repr__(self):
        fmt = lambda a: &#34;/&#34;.join(map(str, a))
        starts = list(map(fmt, zip(*self.start.values())))
        stops = list(map(fmt, zip(*self.stop.values())))
        items = &#34;\n        &#34;.join(
            f&#34;{l}[{a} -&gt; {b}]&#34; for l, a, b in zip(self.label, starts, stops)
        )
        return f&#34;&lt;Commit {items}&gt;&#34;

    def segments(self, label, pod, start=None, stop=None):
        res = []
        (matches,) = where(self.label == label)
        for pos in matches:
            arr_start = tuple(arr[pos] for arr in self.start.values())
            arr_stop = tuple(arr[pos] for arr in self.stop.values())
            if start and start &gt; arr_stop:
                continue
            if stop and stop &lt; arr_start:
                continue

            digest = [arr[pos] for arr in self.digest.values()]
            closed = self.closed[pos]

            sgm = Segment(
                self.schema,
                pod,
                digest,
                start=max(arr_start, start) if start else arr_start,
                stop=min(arr_stop, stop) if stop else arr_stop,
                closed=closed,
            )
            res.append(sgm)
        return res

    def delete_labels(self, rm_labels):
        keep = ~isin(self.label, rm_labels)
        return Commit(
            schema=self.schema,
            label=self.label[keep],
            start={k: v[keep] for k, v in self.start.items()},
            stop={k: v[keep] for k, v in self.stop.items()},
            digest={k: v[keep] for k, v in self.digest.items()},
            length=self.length[keep],
            closed=self.closed[keep],
        )

    def __contains__(self, row):
        start_pos, _ = self.split(row[&#34;label&#34;], row[&#34;start&#34;], row[&#34;stop&#34;])
        if start_pos &gt;= len(self):
            return False
        match_row = self.at(start_pos)
        for attr in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            if match_row[attr] != row[attr]:
                return False
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lakota.commit.Commit.closed_codec"><code class="name">var <span class="ident">closed_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.digest_codec"><code class="name">var <span class="ident">digest_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.label_codec"><code class="name">var <span class="ident">label_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.len_codec"><code class="name">var <span class="ident">len_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lakota.commit.Commit.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>commit, *other_commits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def concat(cls, commit, *other_commits):
    schema = commit.schema
    all_ci = (commit,) + other_commits
    all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

    # Make sure there are no overlaps
    for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
        prv_tail = prv.at(-1)
        nxt_head = nxt.at(0)
        assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
            nxt_head[&#34;label&#34;],
            nxt_head[&#34;start&#34;],
        )

    start = {
        name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
    }
    stop = {
        name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
    }
    digest = {
        name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
    }
    label = concatenate([ci.label for ci in all_ci])
    length = concatenate([ci.length for ci in all_ci])
    closed = concatenate([ci.closed for ci in all_ci])

    return Commit(schema, label, start, stop, digest, length, closed)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>schema, payload)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decode(cls, schema, payload):
    msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
    data = msgpck.decode(payload)[0]
    values = {}
    # Decode starts, stops and digests
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        key_vals = {}
        columns = schema if key == &#34;digest&#34; else schema.idx
        for name in columns:
            codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
            key_vals[name] = codec.decode(data[key][name])
        values[key] = key_vals

    # Decode len and labels
    values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
    values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
    values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])
    return Commit(schema, **values)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.one"><code class="name flex">
<span>def <span class="ident">one</span></span>(<span>schema, label, start, stop, digest, length, closed='both')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def one(cls, schema, label, start, stop, digest, length, closed=&#34;both&#34;):
    label = asarray([label])
    start = dict(zip(schema.idx, (asarray([s]) for s in start)))
    stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
    digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
    length = [length]
    closed = [closed]
    return Commit(schema, label, start, stop, digest, length, closed)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.commit.Commit.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, pos):
    if pos &lt; 0:
        pos = len(self) + pos
    res = {}
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        columns = self.schema if key == &#34;digest&#34; else self.schema.idx
        values = getattr(self, key)
        res[key] = tuple(values[n][pos] for n in columns)

    for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
        res[key] = getattr(self, key)[pos]
    return res</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.delete_labels"><code class="name flex">
<span>def <span class="ident">delete_labels</span></span>(<span>self, rm_labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_labels(self, rm_labels):
    keep = ~isin(self.label, rm_labels)
    return Commit(
        schema=self.schema,
        label=self.label[keep],
        start={k: v[keep] for k, v in self.start.items()},
        stop={k: v[keep] for k, v in self.stop.items()},
        digest={k: v[keep] for k, v in self.digest.items()},
        length=self.length[keep],
        closed=self.closed[keep],
    )</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
    data = {}
    # Encode starts, stops and digests
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        columns = self.schema if key == &#34;digest&#34; else self.schema.idx
        key_vals = {}
        for pos, name in enumerate(columns):
            codec = (
                self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
            )
            arr = getattr(self, key)[name]
            key_vals[name] = codec.encode(arr)
        data[key] = key_vals

    # Encode digests
    for name in self.schema:
        data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

    # Encode length, closed and labels
    data[&#34;length&#34;] = self.len_codec.encode(self.length)
    data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
    data[&#34;label&#34;] = self.label_codec.encode(self.label)
    return msgpck.encode([data])</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, pos):
    return self.slice(None, pos)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.segments"><code class="name flex">
<span>def <span class="ident">segments</span></span>(<span>self, label, pod, start=None, stop=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segments(self, label, pod, start=None, stop=None):
    res = []
    (matches,) = where(self.label == label)
    for pos in matches:
        arr_start = tuple(arr[pos] for arr in self.start.values())
        arr_stop = tuple(arr[pos] for arr in self.stop.values())
        if start and start &gt; arr_stop:
            continue
        if stop and stop &lt; arr_start:
            continue

        digest = [arr[pos] for arr in self.digest.values()]
        closed = self.closed[pos]

        sgm = Segment(
            self.schema,
            pod,
            digest,
            start=max(arr_start, start) if start else arr_start,
            stop=min(arr_stop, stop) if stop else arr_stop,
            closed=closed,
        )
        res.append(sgm)
    return res</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>self, *pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice(self, *pos):
    slc = slice(*pos)
    schema = self.schema
    start = {name: self.start[name][slc] for name in schema.idx}
    stop = {name: self.stop[name][slc] for name in schema.idx}
    digest = {name: self.digest[name][slc] for name in schema}
    label = self.label[slc]
    length = self.length[slc]
    closed = self.closed[slc]
    return Commit(schema, label, start, stop, digest, length, closed)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, label, start, stop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, label, start, stop):
    start_values = {&#34;_label&#34;: self.label}
    start_values.update(self.start)
    stop_values = {&#34;_label&#34;: self.label}
    stop_values.update(self.stop)
    frm_start = Frame(Schema.from_frame(start_values), start_values)
    frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
    start_pos = frm_stop.index((label,) + start, right=True)
    stop_pos = frm_start.index((label,) + stop, right=False)
    return start_pos, stop_pos</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, pos):
    return self.slice(pos, None)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, label, start, stop, digest, length, closed='both')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, label, start, stop, digest, length, closed=&#34;both&#34;):
    if not start &lt;= stop:
        raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
    inner = Commit.one(self.schema, label, start, stop, digest, length, closed)
    if len(self) == 0:
        return inner

    first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
    last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
    if (label, start) &lt;= first and (label, stop) &gt;= last:
        return inner

    start_pos, stop_pos = self.split(label, start, stop)
    # Corner case: we hit right in the middle of an existing row
    if start_pos + 1 == stop_pos:
        row = self.at(start_pos)
        if label == row[&#34;start&#34;] and row[&#34;start&#34;] &lt; start and stop &lt; row[&#34;stop&#34;]:
            start_row = row
            start_row[&#34;stop&#34;] = start
            start_row[&#34;closed&#34;] = (
                &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
            )
            stop_row = self.at(start_pos)
            stop_row[&#34;start&#34;] = stop
            stop_row[&#34;closed&#34;] = (
                &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
            )
            ci = Commit.concat(
                self.head(start_pos),
                Commit.one(schema=self.schema, **start_row),
                inner,
                Commit.one(schema=self.schema, **stop_row),
                self.tail(stop_pos),
            )
            return ci

    # Truncate start_pos row
    head = None
    if start_pos &lt; len(self):
        start_row = self.at(start_pos)
        if (
            label == start_row[&#34;label&#34;]
            and start_row[&#34;start&#34;] &lt; start &lt;= start_row[&#34;stop&#34;]
        ):
            # We hit the right of an existing row
            start_row[&#34;stop&#34;] = start
            # XXX adapt behaviour if current update is not closed==both
            start_row[&#34;closed&#34;] = (
                &#34;left&#34; if start_row[&#34;closed&#34;] in (&#34;left&#34;, &#34;both&#34;) else None
            )
            if start_row[&#34;start&#34;] &lt; start_row[&#34;stop&#34;]:
                head = Commit.concat(
                    self.head(start_pos),
                    Commit.one(schema=self.schema, **start_row),
                )
            # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
            # start_row stop and start are both &#34;overshadowed&#34; by
            # new commit
    if head is None:
        head = self.head(start_pos)

    # Truncate stop_pos row
    tail = None
    stop_row = self.at(stop_pos - 1)
    if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt; stop_row[&#34;stop&#34;]:
        # We hit the left of an existing row
        stop_row[&#34;start&#34;] = stop
        # XXX adapt behavoour if current update is not closed==both
        stop_row[&#34;closed&#34;] = (
            &#34;right&#34; if stop_row[&#34;closed&#34;] in (&#34;right&#34;, &#34;both&#34;) else None
        )
        if stop_row[&#34;start&#34;] &lt; stop_row[&#34;stop&#34;]:
            tail = Commit.concat(
                Commit.one(schema=self.schema, **stop_row),
                self.tail(stop_pos),
            )
        # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
        # stop_row stop and start are both &#34;overshadowed&#34; by
        # new commit
    if tail is None:
        tail = self.tail(stop_pos)

    return Commit.concat(head, inner, tail)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lakota.commit.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>schema, pod, digests, start, stop, closed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Segment:
    def __init__(self, schema, pod, digests, start, stop, closed):
        self.schema = schema
        self.pod = pod
        self.start = start
        self.stop = stop
        self.closed = closed
        self.digest = dict(zip(schema, digests))
        self._frm = None
        self.start_pos = None
        self.stop_pos = None
        self.lock = Lock()

    def __len__(self):
        return len(self.frame)

    def read(self, name, start=None, stop=None):
        if not name in self.frame:
            self.frame[name] = self._read(name)
        return self.frame[name][start:stop]

    def _read(self, name):
        folder, filename = hashed_path(self.digest[name])
        payload = self.pod.cd(folder).read(filename)
        # TODO check payload checksum
        arr = self.schema[name].codec.decode(payload)
        return arr[self.start_pos : self.stop_pos]

    @property
    def frame(self):
        # Use a Frame instance as container to cache columns
        with self.lock:
            if self._frm is not None:
                return self._frm

            cols = {}
            for name in self.schema.idx:
                cols[name] = self._read(name)
            frm = Frame(self.schema, cols)
            self.start_pos, self.stop_pos = frm.index_slice(
                self.start, self.stop, closed=self.closed
            )
            self._frm = frm.slice(self.start_pos, self.stop_pos)
            return frm</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="lakota.commit.Segment.frame"><code class="name">var <span class="ident">frame</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self):
    # Use a Frame instance as container to cache columns
    with self.lock:
        if self._frm is not None:
            return self._frm

        cols = {}
        for name in self.schema.idx:
            cols[name] = self._read(name)
        frm = Frame(self.schema, cols)
        self.start_pos, self.stop_pos = frm.index_slice(
            self.start, self.stop, closed=self.closed
        )
        self._frm = frm.slice(self.start_pos, self.stop_pos)
        return frm</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.commit.Segment.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, name, start=None, stop=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, name, start=None, stop=None):
    if not name in self.frame:
        self.frame[name] = self._read(name)
    return self.frame[name][start:stop]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lakota" href="index.html">lakota</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lakota.commit.Commit" href="#lakota.commit.Commit">Commit</a></code></h4>
<ul class="two-column">
<li><code><a title="lakota.commit.Commit.at" href="#lakota.commit.Commit.at">at</a></code></li>
<li><code><a title="lakota.commit.Commit.closed_codec" href="#lakota.commit.Commit.closed_codec">closed_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.concat" href="#lakota.commit.Commit.concat">concat</a></code></li>
<li><code><a title="lakota.commit.Commit.decode" href="#lakota.commit.Commit.decode">decode</a></code></li>
<li><code><a title="lakota.commit.Commit.delete_labels" href="#lakota.commit.Commit.delete_labels">delete_labels</a></code></li>
<li><code><a title="lakota.commit.Commit.digest_codec" href="#lakota.commit.Commit.digest_codec">digest_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.encode" href="#lakota.commit.Commit.encode">encode</a></code></li>
<li><code><a title="lakota.commit.Commit.head" href="#lakota.commit.Commit.head">head</a></code></li>
<li><code><a title="lakota.commit.Commit.label_codec" href="#lakota.commit.Commit.label_codec">label_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.len_codec" href="#lakota.commit.Commit.len_codec">len_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.one" href="#lakota.commit.Commit.one">one</a></code></li>
<li><code><a title="lakota.commit.Commit.segments" href="#lakota.commit.Commit.segments">segments</a></code></li>
<li><code><a title="lakota.commit.Commit.slice" href="#lakota.commit.Commit.slice">slice</a></code></li>
<li><code><a title="lakota.commit.Commit.split" href="#lakota.commit.Commit.split">split</a></code></li>
<li><code><a title="lakota.commit.Commit.tail" href="#lakota.commit.Commit.tail">tail</a></code></li>
<li><code><a title="lakota.commit.Commit.update" href="#lakota.commit.Commit.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lakota.commit.Segment" href="#lakota.commit.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="lakota.commit.Segment.frame" href="#lakota.commit.Segment.frame">frame</a></code></li>
<li><code><a title="lakota.commit.Segment.read" href="#lakota.commit.Segment.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>