<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lakota.commit API documentation</title>
<meta name="description" content="The `Commit` class is responsible to structure the content of a
commit file. A commit is like a sorted dataframe with the following
columns: `label`, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lakota.commit</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="lakota.commit.Commit" href="#lakota.commit.Commit">Commit</a></code> class is responsible to structure the content of a
commit file. A commit is like a sorted dataframe with the following
columns: <code>label</code>, <code>start</code>, <code>stop</code>, <code>digest</code>, <code>length</code>, <code>closed</code>.</p>
<p>Each row represent a slice of a series: its label, the indexes at
which it starts an stops and the digests of the different columns.</p>
<p>So for a given commit, if we want to know all the data related to a
given series, we can simply filter on the <code>label</code> column. Furthermore
if only a part of the series is needed (for usually between two
dates), we can use <code>start</code> and <code>stop</code> to detect if a row is relevant.</p>
<p>Once one or more rows are identified, the digests allows to know which
files contain the data we want. We can then read and uncompress those
and instanciate a dataframe.</p>
<p>Let's use the command line interface to illustrate this:</p>
<pre><code class="language-shell">$ lakota create temperature &quot;timestamp timestamp*&quot; &quot;value float&quot;
$ cat input.csv | lakota write temperature/Paris
$ cat input.csv | lakota write temperature/Brussels
</code></pre>
<p>We have create two series with the same content.</p>
<p>The <code>rev</code> subcomment with the <code>--extend</code> flag lists revisions and
print their content (the commits):</p>
<pre><code class="language-shell">$ lakota rev temperature -e

Revision: 00000000000-0000000000000000000000000000000000000000.17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653
Date: 2020-12-15 10:27:34.302000
label    start                stop                   length  digests
-------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Paris    2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e


Revision: 17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653.17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b*
Date: 2020-12-15 10:27:38.717000
label     start                stop                   length  digests
--------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Brussels  2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
</code></pre>
<p>(revisions are documented in <code><a title="lakota.changelog" href="changelog.html">lakota.changelog</a></code>)</p>
<p>So we can see the two commits made in the collection, they show us
different states. The first one with only the series <code>Paris</code> and the
second with both. We can use <code>read</code> with verbose flags to illustrate
file access (see comments inlined):</p>
<pre><code class="language-shell">$ lakota -vv read temperature/Brussels
 # The first 4 storage access (1 LIST and 3 READ) are used to identify
 #  where our collection is.
LIST .lakota/00/00/000000000000000000000000000000000000 .
READ .lakota/00/00/000000000000000000000000000000000000 00000000000-0000000000000000000000000000000000000000.17665b9e79b-acf6e197ece6782a6da6e8a50bfd7d9aa3543e90
READ .lakota/6d/1d 7aa3d69158cdfdee236f3b18791204e6e308
READ .lakota/2e/0f f7b7988ee10ef47a8973afa3f9da60b6c892
 # This directory contains our collection, listing it gives us the revisions
LIST .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 .
 # The latest commit is read:
READ .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653.17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b
 # Based on the commit info, we know which file to read for each column
READ .lakota/8d/c2 5a6911f09119919c2b3d177cd4430f43c73a # -&gt; payload of timestamp column
READ .lakota/de/46 c7d97cc7dde24962e31ee5fdee1acadd114e # -&gt; payload of value column
 # The array are then combined in a dataframe and dumped as csv
timestamp,value
2020-06-22T00:00:00,25.0
2020-06-23T00:00:00,24.0
2020-06-24T00:00:00,27.0
2020-06-25T00:00:00,31.0
2020-06-26T00:00:00,32.0
2020-06-27T00:00:00,30.0
</code></pre>
<p>Each time a write is done on a collection, a new revision file is
created, its content is a new commit. This commit is based on the
previous one, usually with an extra line or an update line (or
both). For example, if we update the <code>Paris</code> series, and print the
commits:</p>
<pre><code class="language-shell">
$ cat input-corrected.csv
2020-06-23,24.2
2020-06-24,27.9
2020-06-25,31.0
2020-06-26,32.5
2020-06-27,30.1
2020-06-28,29.2
$ cat input-corrected.csv | lakota write temperature/Paris
$ lakota rev temperature -e
[...snipped...]
Revision: 17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b.17665cf207b-b5ef411d8f000b5eafcdd5c58cc4c26a82ac757e*
Date: 2020-12-15 10:50:41.787000
label     start                stop                   length  digests
--------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Brussels  2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-22T00:00:00  2020-06-23T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-23T00:00:00  2020-06-28T00:00:00         6  1602a81fb4eafda5226880c7ef9145a8dada8cf0 / fda980aa244f5bef17b9feb5faa3e6532d0f815b
</code></pre>
<p>We see two lines for the <code>Paris</code> series. The first one has been
updated (stop is now <code>2020-06-23</code>) and the second one has been
appended. The next time this series is read both line will be
used except if we filter it:</p>
<pre><code class="language-shell">$ lakota -vv read temperature/Paris --greater-than 2020-06-23
[...snipped...]
READ .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b.17665cf207b-b5ef411d8f000b5eafcdd5c58cc4c26a82ac757e
READ .lakota/16/02 a81fb4eafda5226880c7ef9145a8dada8cf0
READ .lakota/fd/a9 80aa244f5bef17b9feb5faa3e6532d0f815b
timestamp,value
2020-06-23T00:00:00,24.2
2020-06-24T00:00:00,27.9
2020-06-25T00:00:00,31.0
2020-06-26T00:00:00,32.5
2020-06-27T00:00:00,30.1
2020-06-28T00:00:00,29.2
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The `Commit` class is responsible to structure the content of a
commit file. A commit is like a sorted dataframe with the following
columns: `label`, `start`, `stop`, `digest`, `length`, `closed`.

Each row represent a slice of a series: its label, the indexes at
which it starts an stops and the digests of the different columns.

So for a given commit, if we want to know all the data related to a
given series, we can simply filter on the `label` column. Furthermore
if only a part of the series is needed (for usually between two
dates), we can use `start` and `stop` to detect if a row is relevant.

Once one or more rows are identified, the digests allows to know which
files contain the data we want. We can then read and uncompress those
and instanciate a dataframe.

Let&#39;s use the command line interface to illustrate this:

```shell
$ lakota create temperature &#34;timestamp timestamp*&#34; &#34;value float&#34;
$ cat input.csv | lakota write temperature/Paris
$ cat input.csv | lakota write temperature/Brussels
```
We have create two series with the same content.


The `rev` subcomment with the `--extend` flag lists revisions and
print their content (the commits):

```shell
$ lakota rev temperature -e

Revision: 00000000000-0000000000000000000000000000000000000000.17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653
Date: 2020-12-15 10:27:34.302000
label    start                stop                   length  digests
-------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Paris    2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e


Revision: 17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653.17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b*
Date: 2020-12-15 10:27:38.717000
label     start                stop                   length  digests
--------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Brussels  2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
```

(revisions are documented in `lakota.changelog`)

So we can see the two commits made in the collection, they show us
different states. The first one with only the series `Paris` and the
second with both. We can use `read` with verbose flags to illustrate
file access (see comments inlined):

```shell
$ lakota -vv read temperature/Brussels
 # The first 4 storage access (1 LIST and 3 READ) are used to identify
 #  where our collection is.
LIST .lakota/00/00/000000000000000000000000000000000000 .
READ .lakota/00/00/000000000000000000000000000000000000 00000000000-0000000000000000000000000000000000000000.17665b9e79b-acf6e197ece6782a6da6e8a50bfd7d9aa3543e90
READ .lakota/6d/1d 7aa3d69158cdfdee236f3b18791204e6e308
READ .lakota/2e/0f f7b7988ee10ef47a8973afa3f9da60b6c892
 # This directory contains our collection, listing it gives us the revisions
LIST .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 .
 # The latest commit is read:
READ .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 17665b9f49e-8e692971744a1222b8a7c706b31e24c8d0a22653.17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b
 # Based on the commit info, we know which file to read for each column
READ .lakota/8d/c2 5a6911f09119919c2b3d177cd4430f43c73a # -&gt; payload of timestamp column
READ .lakota/de/46 c7d97cc7dde24962e31ee5fdee1acadd114e # -&gt; payload of value column
 # The array are then combined in a dataframe and dumped as csv
timestamp,value
2020-06-22T00:00:00,25.0
2020-06-23T00:00:00,24.0
2020-06-24T00:00:00,27.0
2020-06-25T00:00:00,31.0
2020-06-26T00:00:00,32.0
2020-06-27T00:00:00,30.0
```

Each time a write is done on a collection, a new revision file is
created, its content is a new commit. This commit is based on the
previous one, usually with an extra line or an update line (or
both). For example, if we update the `Paris` series, and print the
commits:

```shell

$ cat input-corrected.csv
2020-06-23,24.2
2020-06-24,27.9
2020-06-25,31.0
2020-06-26,32.5
2020-06-27,30.1
2020-06-28,29.2
$ cat input-corrected.csv | lakota write temperature/Paris
$ lakota rev temperature -e
[...snipped...]
Revision: 17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b.17665cf207b-b5ef411d8f000b5eafcdd5c58cc4c26a82ac757e*
Date: 2020-12-15 10:50:41.787000
label     start                stop                   length  digests
--------  -------------------  -------------------  --------  -----------------------------------------------------------------------------------
Brussels  2020-06-22T00:00:00  2020-06-27T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-22T00:00:00  2020-06-23T00:00:00         6  8dc25a6911f09119919c2b3d177cd4430f43c73a / de46c7d97cc7dde24962e31ee5fdee1acadd114e
Paris     2020-06-23T00:00:00  2020-06-28T00:00:00         6  1602a81fb4eafda5226880c7ef9145a8dada8cf0 / fda980aa244f5bef17b9feb5faa3e6532d0f815b
```

We see two lines for the `Paris` series. The first one has been
updated (stop is now `2020-06-23`) and the second one has been
appended. The next time this series is read both line will be
used except if we filter it:

```shell
$ lakota -vv read temperature/Paris --greater-than 2020-06-23
[...snipped...]
READ .lakota/70/33/e90fcdda169d2f5d08da17507b0c5db52029 17665ba05dd-1b188c517bb45f98669620e4822a67a81dd15b3b.17665cf207b-b5ef411d8f000b5eafcdd5c58cc4c26a82ac757e
READ .lakota/16/02 a81fb4eafda5226880c7ef9145a8dada8cf0
READ .lakota/fd/a9 80aa244f5bef17b9feb5faa3e6532d0f815b
timestamp,value
2020-06-23T00:00:00,24.2
2020-06-24T00:00:00,27.9
2020-06-25T00:00:00,31.0
2020-06-26T00:00:00,32.5
2020-06-27T00:00:00,30.1
2020-06-28T00:00:00,29.2
```
&#34;&#34;&#34;

from itertools import chain
from threading import Lock

from numcodecs import registry
from numpy import asarray, concatenate, isin, repeat, where

from .frame import Frame
from .schema import Codec, Schema
from .utils import Closed, Pool, hashed_path

__all__ = [&#34;Commit&#34;, &#34;Segment&#34;]


class Commit:

    digest_codec = Codec(&#34;U&#34;)  # FIXME use better encoding
    len_codec = Codec(&#34;int&#34;)
    label_codec = Codec(&#34;str&#34;)
    closed_codec = Codec(&#34;str&#34;)  # Could be i1

    def __init__(self, schema, label, start, stop, digest, length, closed, embedded):
        assert list(digest) == list(schema)
        self.schema = schema
        self.label = label  # Array of str
        self.start = start  # Dict of Arrays
        self.stop = stop  # Dict of arrays
        self.digest = digest  # Dict of arrays
        self.length = length  # Array of int
        self.closed = closed  # Array of (&#34;l&#34;, &#34;r&#34;, &#34;b&#34;, &#34;n&#34;)
        self.embedded = embedded or {}

    @classmethod
    def one(
        cls,
        schema,
        label,
        start,
        stop,
        digest,
        length,
        closed=Closed.BOTH,
        embedded=None,
    ):
        closed = Closed.cast(closed)
        label = asarray([label])
        start = dict(zip(schema.idx, (asarray([s]) for s in start)))
        stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
        digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
        length = [length]
        closed = [closed.short]
        return Commit(schema, label, start, stop, digest, length, closed, embedded)

    @classmethod
    def decode(cls, schema, payload):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = msgpck.decode(payload)[0]
        values = {}
        # Decode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            key_vals = {}
            columns = schema if key == &#34;digest&#34; else schema.idx
            for name in columns:
                codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
                key_vals[name] = codec.decode(data[key][name])
            values[key] = key_vals

        # Decode len and labels
        values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
        values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
        values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])

        # Embedded data will be decoded on demand
        values[&#34;embedded&#34;] = data.get(&#34;embedded&#34;)
        return Commit(schema, **values)

    def encode(self):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = {}
        # Encode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            key_vals = {}
            for pos, name in enumerate(columns):
                codec = (
                    self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
                )
                arr = getattr(self, key)[name]
                key_vals[name] = codec.encode(arr)
            data[key] = key_vals

        # Encode digests
        for name in self.schema:
            data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

        # Encode length, closed and labels
        data[&#34;length&#34;] = self.len_codec.encode(self.length)
        data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
        data[&#34;label&#34;] = self.label_codec.encode(self.label)
        # Keep only embedded data referenced by self.digest
        keep_digests = (
            set(chain.from_iterable(self.digest.values())) &amp; self.embedded.keys()
        )
        embedded = {d: self.embedded[d] for d in sorted(keep_digests)}
        data[&#34;embedded&#34;] = embedded
        return msgpck.encode([data])

    def split(self, label, start, stop):
        start_values = {&#34;_label&#34;: self.label}
        start_values.update(self.start)
        stop_values = {&#34;_label&#34;: self.label}
        stop_values.update(self.stop)
        frm_start = Frame(Schema.from_frame(start_values), start_values)
        frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
        start_pos = frm_stop.index((label,) + start, right=True)
        stop_pos = frm_start.index((label,) + stop, right=False)
        return start_pos, stop_pos

    def __len__(self):
        return len(self.label)

    def at(self, pos):
        if pos &lt; 0:
            pos = len(self) + pos
        res = {}
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            values = getattr(self, key)
            res[key] = tuple(values[n][pos] for n in columns)

        for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
            res[key] = getattr(self, key)[pos]
        res[&#34;embedded&#34;] = self.embedded
        return res

    def update(self, label, start, stop, digest, length, closed=&#34;b&#34;, embedded=None):
        closed = Closed.cast(closed)
        if not start &lt;= stop:
            raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
        inner = Commit.one(
            self.schema, label, start, stop, digest, length, closed, embedded
        )
        if len(self) == 0:
            return inner

        if embedded:
            self.embedded.update(embedded)

        first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
        last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
        if (label, start) &lt; first and (label, stop) &gt; last:
            return inner

        start_pos, stop_pos = self.split(label, start, stop)
        # Truncate start_pos row
        head = None
        # start_pos is the result of a bisect_right, so we have to
        # check the slot on the left that may be perfect match
        start_row = None
        if start_pos &gt; 0:
            prev_row = self.at(start_pos - 1)
            if prev_row[&#34;stop&#34;] == start:
                start_pos -= 1
                start_row = prev_row
        if start_row is None:
            start_row = self.at(min(start_pos, len(self) - 1))

        if (
            label == start_row[&#34;label&#34;]
            and start_row[&#34;start&#34;] &lt;= start &lt;= start_row[&#34;stop&#34;]
        ):
            # We hit the right of an existing row
            start_row[&#34;stop&#34;] = start
            # If closed is open/close on left, start_row become the
            # opposite on right:
            start_row[&#34;closed&#34;] = Closed[start_row[&#34;closed&#34;]].set_right(not closed.left)

            if (
                start_row[&#34;start&#34;] == start_row[&#34;stop&#34;]
                and start_row[&#34;closed&#34;] != Closed.BOTH
            ):
                # Ignore star_row
                head = self.head(start_pos)
            else:
                head = Commit.concat(
                    self.head(start_pos),
                    Commit.one(schema=self.schema, **start_row),
                )
            # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
            # start_row stop and start are both &#34;overshadowed&#34; by
            # new commit

        if head is None:
            head = self.head(start_pos)

        # Truncate stop_pos row
        tail = None
        # stop_pos is the result of a bisect_left, so we have to
        # check the slot on the right that may be perfect match
        stop_row = None
        if stop_pos &lt; len(self):
            next_row = self.at(stop_pos)
            if next_row[&#34;start&#34;] == stop:
                stop_row = next_row
                stop_pos += 1
        if stop_row is None:
            stop_row = self.at(max(0, stop_pos - 1))

        if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt;= stop_row[&#34;stop&#34;]:
            # We hit the left of an existing row
            stop_row[&#34;start&#34;] = stop
            # If closed is open/close on right, stop_row become the
            # opposite on left:
            stop_row[&#34;closed&#34;] = Closed[stop_row[&#34;closed&#34;]].set_left(not closed.right)

            if (
                stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;]
                and start_row[&#34;closed&#34;] != Closed.BOTH
            ):
                # Ignore stop_row
                tail = self.tail(stop_pos)
            else:
                tail = Commit.concat(
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
            # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
            # stop_row stop and start are both &#34;overshadowed&#34; by
            # new commit
        if tail is None:
            tail = self.tail(stop_pos)
        return Commit.concat(head, inner, tail)

    def slice(self, *pos):
        slc = slice(*pos)
        schema = self.schema
        start = {name: self.start[name][slc] for name in schema.idx}
        stop = {name: self.stop[name][slc] for name in schema.idx}
        digest = {name: self.digest[name][slc] for name in schema}
        label = self.label[slc]
        length = self.length[slc]
        closed = self.closed[slc]
        return Commit(schema, label, start, stop, digest, length, closed, self.embedded)

    def head(self, pos):
        return self.slice(None, pos)

    def tail(self, pos):
        return self.slice(pos, None)

    @classmethod
    def concat(cls, commit, *other_commits):
        schema = commit.schema
        all_ci = (commit,) + other_commits
        all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

        # Make sure there are no overlaps
        for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
            prv_tail = prv.at(-1)
            nxt_head = nxt.at(0)
            assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
                nxt_head[&#34;label&#34;],
                nxt_head[&#34;start&#34;],
            )

        start = {
            name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
        }
        stop = {
            name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
        }
        digest = {
            name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
        }
        label = concatenate([ci.label for ci in all_ci])
        length = concatenate([ci.length for ci in all_ci])
        closed = concatenate([ci.closed for ci in all_ci])
        embedded = {}
        for ci in all_ci:
            embedded.update(ci.embedded)
        return Commit(schema, label, start, stop, digest, length, closed, embedded)

    def __repr__(self):
        fmt = lambda a: &#34;/&#34;.join(map(str, a))
        starts = list(map(fmt, zip(*self.start.values())))
        stops = list(map(fmt, zip(*self.stop.values())))
        items = &#34;\n        &#34;.join(
            f&#34;{l}[{a} -&gt; {b} ({c})]&#34;
            for l, a, b, c in zip(self.label, starts, stops, self.closed)
        )
        return f&#34;&lt;Commit {items}&gt;&#34;

    def match(self, label):
        (matches,) = where(self.label == label)
        for pos in matches:
            yield self.at(pos)

    def segments(self, label, pod, start=None, stop=None, closed=Closed.BOTH):
        closed = Closed.cast(closed)

        # If start (or stop) is not set, and the left (right) side is
        # not closed, we ignore the very first (last) item, which
        # makes no sense
        if start is None:
            closed = closed.set_left(True)
        if stop is None:
            closed = closed.set_right(True)
        res = []

        for row in self.match(
            label
        ):  # XXX allow to pass condition instead of simple start-stop ?
            arr_start = row[&#34;start&#34;]
            arr_stop = row[&#34;stop&#34;]
            arr_closed = Closed[row[&#34;closed&#34;]]
            if start:
                if start &gt; arr_stop:
                    # start is on the right of the array
                    continue
                elif not arr_closed.right and start == arr_stop:
                    # Same
                    continue
                elif start &gt; arr_start:
                    # `closed` &#34;win&#34; over arr_closed on the left
                    arr_closed = arr_closed.set_left(closed.left)
                    arr_start = start
                elif start == arr_start and arr_closed.left:
                    # `closed` &#34;win&#34; only if array left is not already
                    # open
                    arr_closed = arr_closed.set_left(closed.left)

            if stop:
                if stop &lt; arr_start:
                    continue
                elif not arr_closed.left and stop == arr_start:
                    continue
                elif stop &lt; arr_stop:
                    # closed &#34;win&#34; over arr_closed on the right
                    arr_closed = arr_closed.set_right(closed.right)
                    arr_stop = stop
                elif stop == arr_stop and arr_closed.right:
                    arr_closed = arr_closed.set_right(closed.right)
            sgm = Segment(
                self,
                pod,
                row[&#34;digest&#34;],
                start=arr_start,
                stop=arr_stop,
                closed=arr_closed,
            )
            res.append(sgm)
        return res

    def delete_labels(self, rm_labels):
        keep = ~isin(self.label, rm_labels)
        return self.mask(keep)

    def mask(self, keep):
        return Commit(
            schema=self.schema,
            label=self.label[keep],
            start={k: v[keep] for k, v in self.start.items()},
            stop={k: v[keep] for k, v in self.stop.items()},
            digest={k: v[keep] for k, v in self.digest.items()},
            length=self.length[keep],
            closed=self.closed[keep],
            embedded=self.embedded,
        )

    def rename_label(self, from_label, to_label):
        # First we create an extract with `from_label` only
        extract = self.mask(self.label == from_label)
        base_ci = self.delete_labels(from_label)

        # replace label in extract
        extract.label = repeat(to_label, len(extract))

        # Re-inject it
        for pos in range(len(extract)):
            row = extract.at(pos)
            base_ci = base_ci.update(**row)

        return base_ci

    def __contains__(self, row):
        start_pos, _ = self.split(row[&#34;label&#34;], row[&#34;start&#34;], row[&#34;stop&#34;])
        if start_pos &gt;= len(self):
            return False
        match_row = self.at(start_pos)
        for attr in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            if match_row[attr] != row[attr]:
                return False
        return True


class Segment:
    def __init__(self, commit, pod, digests, start, stop, closed):
        self.commit = commit
        self.pod = pod
        self.start = start
        self.stop = stop
        self.closed = closed
        self.digest = dict(zip(commit.schema, digests))
        self._frm = None
        self.start_pos = None
        self.stop_pos = None
        self.lock = Lock()

    def __len__(self):
        return len(self.frame)

    def read(self, name, start_pos=None, stop_pos=None):
        # Prime cache
        if not name in self.frame:
            self.frame[name] = self._read(name)
        return self.frame[name][start_pos:stop_pos]

    def _read(self, name):
        dig = self.digest[name]
        # check first if content is not already in commit
        data = self.commit.embedded.get(dig)
        if data is None:
            folder, filename = hashed_path(dig)
            sub_pod = self.pod.cd(folder)
            try:
                data = sub_pod.read(filename)
            except FileNotFoundError:
                for f in sub_pod.ls():
                    # File is in soft-delete mode
                    if f.startswith(filename):
                        data = sub_pod.read(f)
                        break
        arr = self.commit.schema[name].codec.decode(data)
        return arr[self.start_pos : self.stop_pos]

    @property
    def frame(self):
        # Use a Frame instance as container to cache columns
        with self.lock:
            if self._frm is not None:
                return self._frm

            cols = {}
            # with Pool() as pool: # TODO need a smarter pool
            #     for name in self.commit.schema.idx:
            #         pool.submit(lambda: cols.update({name: self._read(name)}))
            for name in self.commit.schema.idx:
                cols[name] = self._read(name)

            frm = Frame(self.commit.schema, cols)
            self.start_pos, self.stop_pos = frm.index_slice(
                self.start, self.stop, closed=self.closed
            )
            self._frm = frm.slice(self.start_pos, self.stop_pos)
            return self._frm</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lakota.commit.Commit"><code class="flex name class">
<span>class <span class="ident">Commit</span></span>
<span>(</span><span>schema, label, start, stop, digest, length, closed, embedded)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Commit:

    digest_codec = Codec(&#34;U&#34;)  # FIXME use better encoding
    len_codec = Codec(&#34;int&#34;)
    label_codec = Codec(&#34;str&#34;)
    closed_codec = Codec(&#34;str&#34;)  # Could be i1

    def __init__(self, schema, label, start, stop, digest, length, closed, embedded):
        assert list(digest) == list(schema)
        self.schema = schema
        self.label = label  # Array of str
        self.start = start  # Dict of Arrays
        self.stop = stop  # Dict of arrays
        self.digest = digest  # Dict of arrays
        self.length = length  # Array of int
        self.closed = closed  # Array of (&#34;l&#34;, &#34;r&#34;, &#34;b&#34;, &#34;n&#34;)
        self.embedded = embedded or {}

    @classmethod
    def one(
        cls,
        schema,
        label,
        start,
        stop,
        digest,
        length,
        closed=Closed.BOTH,
        embedded=None,
    ):
        closed = Closed.cast(closed)
        label = asarray([label])
        start = dict(zip(schema.idx, (asarray([s]) for s in start)))
        stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
        digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
        length = [length]
        closed = [closed.short]
        return Commit(schema, label, start, stop, digest, length, closed, embedded)

    @classmethod
    def decode(cls, schema, payload):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = msgpck.decode(payload)[0]
        values = {}
        # Decode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            key_vals = {}
            columns = schema if key == &#34;digest&#34; else schema.idx
            for name in columns:
                codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
                key_vals[name] = codec.decode(data[key][name])
            values[key] = key_vals

        # Decode len and labels
        values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
        values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
        values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])

        # Embedded data will be decoded on demand
        values[&#34;embedded&#34;] = data.get(&#34;embedded&#34;)
        return Commit(schema, **values)

    def encode(self):
        msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
        data = {}
        # Encode starts, stops and digests
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            key_vals = {}
            for pos, name in enumerate(columns):
                codec = (
                    self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
                )
                arr = getattr(self, key)[name]
                key_vals[name] = codec.encode(arr)
            data[key] = key_vals

        # Encode digests
        for name in self.schema:
            data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

        # Encode length, closed and labels
        data[&#34;length&#34;] = self.len_codec.encode(self.length)
        data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
        data[&#34;label&#34;] = self.label_codec.encode(self.label)
        # Keep only embedded data referenced by self.digest
        keep_digests = (
            set(chain.from_iterable(self.digest.values())) &amp; self.embedded.keys()
        )
        embedded = {d: self.embedded[d] for d in sorted(keep_digests)}
        data[&#34;embedded&#34;] = embedded
        return msgpck.encode([data])

    def split(self, label, start, stop):
        start_values = {&#34;_label&#34;: self.label}
        start_values.update(self.start)
        stop_values = {&#34;_label&#34;: self.label}
        stop_values.update(self.stop)
        frm_start = Frame(Schema.from_frame(start_values), start_values)
        frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
        start_pos = frm_stop.index((label,) + start, right=True)
        stop_pos = frm_start.index((label,) + stop, right=False)
        return start_pos, stop_pos

    def __len__(self):
        return len(self.label)

    def at(self, pos):
        if pos &lt; 0:
            pos = len(self) + pos
        res = {}
        for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            columns = self.schema if key == &#34;digest&#34; else self.schema.idx
            values = getattr(self, key)
            res[key] = tuple(values[n][pos] for n in columns)

        for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
            res[key] = getattr(self, key)[pos]
        res[&#34;embedded&#34;] = self.embedded
        return res

    def update(self, label, start, stop, digest, length, closed=&#34;b&#34;, embedded=None):
        closed = Closed.cast(closed)
        if not start &lt;= stop:
            raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
        inner = Commit.one(
            self.schema, label, start, stop, digest, length, closed, embedded
        )
        if len(self) == 0:
            return inner

        if embedded:
            self.embedded.update(embedded)

        first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
        last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
        if (label, start) &lt; first and (label, stop) &gt; last:
            return inner

        start_pos, stop_pos = self.split(label, start, stop)
        # Truncate start_pos row
        head = None
        # start_pos is the result of a bisect_right, so we have to
        # check the slot on the left that may be perfect match
        start_row = None
        if start_pos &gt; 0:
            prev_row = self.at(start_pos - 1)
            if prev_row[&#34;stop&#34;] == start:
                start_pos -= 1
                start_row = prev_row
        if start_row is None:
            start_row = self.at(min(start_pos, len(self) - 1))

        if (
            label == start_row[&#34;label&#34;]
            and start_row[&#34;start&#34;] &lt;= start &lt;= start_row[&#34;stop&#34;]
        ):
            # We hit the right of an existing row
            start_row[&#34;stop&#34;] = start
            # If closed is open/close on left, start_row become the
            # opposite on right:
            start_row[&#34;closed&#34;] = Closed[start_row[&#34;closed&#34;]].set_right(not closed.left)

            if (
                start_row[&#34;start&#34;] == start_row[&#34;stop&#34;]
                and start_row[&#34;closed&#34;] != Closed.BOTH
            ):
                # Ignore star_row
                head = self.head(start_pos)
            else:
                head = Commit.concat(
                    self.head(start_pos),
                    Commit.one(schema=self.schema, **start_row),
                )
            # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
            # start_row stop and start are both &#34;overshadowed&#34; by
            # new commit

        if head is None:
            head = self.head(start_pos)

        # Truncate stop_pos row
        tail = None
        # stop_pos is the result of a bisect_left, so we have to
        # check the slot on the right that may be perfect match
        stop_row = None
        if stop_pos &lt; len(self):
            next_row = self.at(stop_pos)
            if next_row[&#34;start&#34;] == stop:
                stop_row = next_row
                stop_pos += 1
        if stop_row is None:
            stop_row = self.at(max(0, stop_pos - 1))

        if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt;= stop_row[&#34;stop&#34;]:
            # We hit the left of an existing row
            stop_row[&#34;start&#34;] = stop
            # If closed is open/close on right, stop_row become the
            # opposite on left:
            stop_row[&#34;closed&#34;] = Closed[stop_row[&#34;closed&#34;]].set_left(not closed.right)

            if (
                stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;]
                and start_row[&#34;closed&#34;] != Closed.BOTH
            ):
                # Ignore stop_row
                tail = self.tail(stop_pos)
            else:
                tail = Commit.concat(
                    Commit.one(schema=self.schema, **stop_row),
                    self.tail(stop_pos),
                )
            # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
            # stop_row stop and start are both &#34;overshadowed&#34; by
            # new commit
        if tail is None:
            tail = self.tail(stop_pos)
        return Commit.concat(head, inner, tail)

    def slice(self, *pos):
        slc = slice(*pos)
        schema = self.schema
        start = {name: self.start[name][slc] for name in schema.idx}
        stop = {name: self.stop[name][slc] for name in schema.idx}
        digest = {name: self.digest[name][slc] for name in schema}
        label = self.label[slc]
        length = self.length[slc]
        closed = self.closed[slc]
        return Commit(schema, label, start, stop, digest, length, closed, self.embedded)

    def head(self, pos):
        return self.slice(None, pos)

    def tail(self, pos):
        return self.slice(pos, None)

    @classmethod
    def concat(cls, commit, *other_commits):
        schema = commit.schema
        all_ci = (commit,) + other_commits
        all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

        # Make sure there are no overlaps
        for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
            prv_tail = prv.at(-1)
            nxt_head = nxt.at(0)
            assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
                nxt_head[&#34;label&#34;],
                nxt_head[&#34;start&#34;],
            )

        start = {
            name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
        }
        stop = {
            name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
        }
        digest = {
            name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
        }
        label = concatenate([ci.label for ci in all_ci])
        length = concatenate([ci.length for ci in all_ci])
        closed = concatenate([ci.closed for ci in all_ci])
        embedded = {}
        for ci in all_ci:
            embedded.update(ci.embedded)
        return Commit(schema, label, start, stop, digest, length, closed, embedded)

    def __repr__(self):
        fmt = lambda a: &#34;/&#34;.join(map(str, a))
        starts = list(map(fmt, zip(*self.start.values())))
        stops = list(map(fmt, zip(*self.stop.values())))
        items = &#34;\n        &#34;.join(
            f&#34;{l}[{a} -&gt; {b} ({c})]&#34;
            for l, a, b, c in zip(self.label, starts, stops, self.closed)
        )
        return f&#34;&lt;Commit {items}&gt;&#34;

    def match(self, label):
        (matches,) = where(self.label == label)
        for pos in matches:
            yield self.at(pos)

    def segments(self, label, pod, start=None, stop=None, closed=Closed.BOTH):
        closed = Closed.cast(closed)

        # If start (or stop) is not set, and the left (right) side is
        # not closed, we ignore the very first (last) item, which
        # makes no sense
        if start is None:
            closed = closed.set_left(True)
        if stop is None:
            closed = closed.set_right(True)
        res = []

        for row in self.match(
            label
        ):  # XXX allow to pass condition instead of simple start-stop ?
            arr_start = row[&#34;start&#34;]
            arr_stop = row[&#34;stop&#34;]
            arr_closed = Closed[row[&#34;closed&#34;]]
            if start:
                if start &gt; arr_stop:
                    # start is on the right of the array
                    continue
                elif not arr_closed.right and start == arr_stop:
                    # Same
                    continue
                elif start &gt; arr_start:
                    # `closed` &#34;win&#34; over arr_closed on the left
                    arr_closed = arr_closed.set_left(closed.left)
                    arr_start = start
                elif start == arr_start and arr_closed.left:
                    # `closed` &#34;win&#34; only if array left is not already
                    # open
                    arr_closed = arr_closed.set_left(closed.left)

            if stop:
                if stop &lt; arr_start:
                    continue
                elif not arr_closed.left and stop == arr_start:
                    continue
                elif stop &lt; arr_stop:
                    # closed &#34;win&#34; over arr_closed on the right
                    arr_closed = arr_closed.set_right(closed.right)
                    arr_stop = stop
                elif stop == arr_stop and arr_closed.right:
                    arr_closed = arr_closed.set_right(closed.right)
            sgm = Segment(
                self,
                pod,
                row[&#34;digest&#34;],
                start=arr_start,
                stop=arr_stop,
                closed=arr_closed,
            )
            res.append(sgm)
        return res

    def delete_labels(self, rm_labels):
        keep = ~isin(self.label, rm_labels)
        return self.mask(keep)

    def mask(self, keep):
        return Commit(
            schema=self.schema,
            label=self.label[keep],
            start={k: v[keep] for k, v in self.start.items()},
            stop={k: v[keep] for k, v in self.stop.items()},
            digest={k: v[keep] for k, v in self.digest.items()},
            length=self.length[keep],
            closed=self.closed[keep],
            embedded=self.embedded,
        )

    def rename_label(self, from_label, to_label):
        # First we create an extract with `from_label` only
        extract = self.mask(self.label == from_label)
        base_ci = self.delete_labels(from_label)

        # replace label in extract
        extract.label = repeat(to_label, len(extract))

        # Re-inject it
        for pos in range(len(extract)):
            row = extract.at(pos)
            base_ci = base_ci.update(**row)

        return base_ci

    def __contains__(self, row):
        start_pos, _ = self.split(row[&#34;label&#34;], row[&#34;start&#34;], row[&#34;stop&#34;])
        if start_pos &gt;= len(self):
            return False
        match_row = self.at(start_pos)
        for attr in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
            if match_row[attr] != row[attr]:
                return False
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lakota.commit.Commit.closed_codec"><code class="name">var <span class="ident">closed_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.digest_codec"><code class="name">var <span class="ident">digest_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.label_codec"><code class="name">var <span class="ident">label_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lakota.commit.Commit.len_codec"><code class="name">var <span class="ident">len_codec</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lakota.commit.Commit.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>commit, *other_commits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def concat(cls, commit, *other_commits):
    schema = commit.schema
    all_ci = (commit,) + other_commits
    all_ci = tuple(ci for ci in all_ci if len(ci) &gt; 0)

    # Make sure there are no overlaps
    for prv, nxt in zip(all_ci[:-1], all_ci[1:]):
        prv_tail = prv.at(-1)
        nxt_head = nxt.at(0)
        assert (prv_tail[&#34;label&#34;], prv_tail[&#34;stop&#34;]) &lt;= (
            nxt_head[&#34;label&#34;],
            nxt_head[&#34;start&#34;],
        )

    start = {
        name: concatenate([ci.start[name] for ci in all_ci]) for name in schema.idx
    }
    stop = {
        name: concatenate([ci.stop[name] for ci in all_ci]) for name in schema.idx
    }
    digest = {
        name: concatenate([ci.digest[name] for ci in all_ci]) for name in schema
    }
    label = concatenate([ci.label for ci in all_ci])
    length = concatenate([ci.length for ci in all_ci])
    closed = concatenate([ci.closed for ci in all_ci])
    embedded = {}
    for ci in all_ci:
        embedded.update(ci.embedded)
    return Commit(schema, label, start, stop, digest, length, closed, embedded)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>schema, payload)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decode(cls, schema, payload):
    msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
    data = msgpck.decode(payload)[0]
    values = {}
    # Decode starts, stops and digests
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        key_vals = {}
        columns = schema if key == &#34;digest&#34; else schema.idx
        for name in columns:
            codec = cls.digest_codec if key == &#34;digest&#34; else schema[name].codec
            key_vals[name] = codec.decode(data[key][name])
        values[key] = key_vals

    # Decode len and labels
    values[&#34;length&#34;] = cls.len_codec.decode(data[&#34;length&#34;])
    values[&#34;label&#34;] = cls.label_codec.decode(data[&#34;label&#34;])
    values[&#34;closed&#34;] = cls.closed_codec.decode(data[&#34;closed&#34;])

    # Embedded data will be decoded on demand
    values[&#34;embedded&#34;] = data.get(&#34;embedded&#34;)
    return Commit(schema, **values)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.one"><code class="name flex">
<span>def <span class="ident">one</span></span>(<span>schema, label, start, stop, digest, length, closed=Closed.BOTH, embedded=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def one(
    cls,
    schema,
    label,
    start,
    stop,
    digest,
    length,
    closed=Closed.BOTH,
    embedded=None,
):
    closed = Closed.cast(closed)
    label = asarray([label])
    start = dict(zip(schema.idx, (asarray([s]) for s in start)))
    stop = dict(zip(schema.idx, (asarray([s]) for s in stop)))
    digest = dict(zip(schema, (asarray([d], dtype=&#34;U&#34;) for d in digest)))
    length = [length]
    closed = [closed.short]
    return Commit(schema, label, start, stop, digest, length, closed, embedded)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.commit.Commit.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, pos):
    if pos &lt; 0:
        pos = len(self) + pos
    res = {}
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        columns = self.schema if key == &#34;digest&#34; else self.schema.idx
        values = getattr(self, key)
        res[key] = tuple(values[n][pos] for n in columns)

    for key in (&#34;label&#34;, &#34;length&#34;, &#34;closed&#34;):
        res[key] = getattr(self, key)[pos]
    res[&#34;embedded&#34;] = self.embedded
    return res</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.delete_labels"><code class="name flex">
<span>def <span class="ident">delete_labels</span></span>(<span>self, rm_labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_labels(self, rm_labels):
    keep = ~isin(self.label, rm_labels)
    return self.mask(keep)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
    msgpck = registry.codec_registry[&#34;msgpack2&#34;]()
    data = {}
    # Encode starts, stops and digests
    for key in (&#34;start&#34;, &#34;stop&#34;, &#34;digest&#34;):
        columns = self.schema if key == &#34;digest&#34; else self.schema.idx
        key_vals = {}
        for pos, name in enumerate(columns):
            codec = (
                self.digest_codec if key == &#34;digest&#34; else self.schema[name].codec
            )
            arr = getattr(self, key)[name]
            key_vals[name] = codec.encode(arr)
        data[key] = key_vals

    # Encode digests
    for name in self.schema:
        data[&#34;digest&#34;][name] = self.digest_codec.encode(self.digest[name])

    # Encode length, closed and labels
    data[&#34;length&#34;] = self.len_codec.encode(self.length)
    data[&#34;closed&#34;] = self.closed_codec.encode(self.closed)
    data[&#34;label&#34;] = self.label_codec.encode(self.label)
    # Keep only embedded data referenced by self.digest
    keep_digests = (
        set(chain.from_iterable(self.digest.values())) &amp; self.embedded.keys()
    )
    embedded = {d: self.embedded[d] for d in sorted(keep_digests)}
    data[&#34;embedded&#34;] = embedded
    return msgpck.encode([data])</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, pos):
    return self.slice(None, pos)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, keep)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, keep):
    return Commit(
        schema=self.schema,
        label=self.label[keep],
        start={k: v[keep] for k, v in self.start.items()},
        stop={k: v[keep] for k, v in self.stop.items()},
        digest={k: v[keep] for k, v in self.digest.items()},
        length=self.length[keep],
        closed=self.closed[keep],
        embedded=self.embedded,
    )</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, label):
    (matches,) = where(self.label == label)
    for pos in matches:
        yield self.at(pos)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.rename_label"><code class="name flex">
<span>def <span class="ident">rename_label</span></span>(<span>self, from_label, to_label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_label(self, from_label, to_label):
    # First we create an extract with `from_label` only
    extract = self.mask(self.label == from_label)
    base_ci = self.delete_labels(from_label)

    # replace label in extract
    extract.label = repeat(to_label, len(extract))

    # Re-inject it
    for pos in range(len(extract)):
        row = extract.at(pos)
        base_ci = base_ci.update(**row)

    return base_ci</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.segments"><code class="name flex">
<span>def <span class="ident">segments</span></span>(<span>self, label, pod, start=None, stop=None, closed=Closed.BOTH)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segments(self, label, pod, start=None, stop=None, closed=Closed.BOTH):
    closed = Closed.cast(closed)

    # If start (or stop) is not set, and the left (right) side is
    # not closed, we ignore the very first (last) item, which
    # makes no sense
    if start is None:
        closed = closed.set_left(True)
    if stop is None:
        closed = closed.set_right(True)
    res = []

    for row in self.match(
        label
    ):  # XXX allow to pass condition instead of simple start-stop ?
        arr_start = row[&#34;start&#34;]
        arr_stop = row[&#34;stop&#34;]
        arr_closed = Closed[row[&#34;closed&#34;]]
        if start:
            if start &gt; arr_stop:
                # start is on the right of the array
                continue
            elif not arr_closed.right and start == arr_stop:
                # Same
                continue
            elif start &gt; arr_start:
                # `closed` &#34;win&#34; over arr_closed on the left
                arr_closed = arr_closed.set_left(closed.left)
                arr_start = start
            elif start == arr_start and arr_closed.left:
                # `closed` &#34;win&#34; only if array left is not already
                # open
                arr_closed = arr_closed.set_left(closed.left)

        if stop:
            if stop &lt; arr_start:
                continue
            elif not arr_closed.left and stop == arr_start:
                continue
            elif stop &lt; arr_stop:
                # closed &#34;win&#34; over arr_closed on the right
                arr_closed = arr_closed.set_right(closed.right)
                arr_stop = stop
            elif stop == arr_stop and arr_closed.right:
                arr_closed = arr_closed.set_right(closed.right)
        sgm = Segment(
            self,
            pod,
            row[&#34;digest&#34;],
            start=arr_start,
            stop=arr_stop,
            closed=arr_closed,
        )
        res.append(sgm)
    return res</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>self, *pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice(self, *pos):
    slc = slice(*pos)
    schema = self.schema
    start = {name: self.start[name][slc] for name in schema.idx}
    stop = {name: self.stop[name][slc] for name in schema.idx}
    digest = {name: self.digest[name][slc] for name in schema}
    label = self.label[slc]
    length = self.length[slc]
    closed = self.closed[slc]
    return Commit(schema, label, start, stop, digest, length, closed, self.embedded)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, label, start, stop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, label, start, stop):
    start_values = {&#34;_label&#34;: self.label}
    start_values.update(self.start)
    stop_values = {&#34;_label&#34;: self.label}
    stop_values.update(self.stop)
    frm_start = Frame(Schema.from_frame(start_values), start_values)
    frm_stop = Frame(Schema.from_frame(stop_values), stop_values)
    start_pos = frm_stop.index((label,) + start, right=True)
    stop_pos = frm_start.index((label,) + stop, right=False)
    return start_pos, stop_pos</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, pos):
    return self.slice(pos, None)</code></pre>
</details>
</dd>
<dt id="lakota.commit.Commit.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, label, start, stop, digest, length, closed='b', embedded=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, label, start, stop, digest, length, closed=&#34;b&#34;, embedded=None):
    closed = Closed.cast(closed)
    if not start &lt;= stop:
        raise ValueError(f&#34;Invalid range {start} -&gt; {stop}&#34;)
    inner = Commit.one(
        self.schema, label, start, stop, digest, length, closed, embedded
    )
    if len(self) == 0:
        return inner

    if embedded:
        self.embedded.update(embedded)

    first = (self.at(0)[&#34;label&#34;], self.at(0)[&#34;start&#34;])
    last = (self.at(-1)[&#34;label&#34;], self.at(-1)[&#34;stop&#34;])
    if (label, start) &lt; first and (label, stop) &gt; last:
        return inner

    start_pos, stop_pos = self.split(label, start, stop)
    # Truncate start_pos row
    head = None
    # start_pos is the result of a bisect_right, so we have to
    # check the slot on the left that may be perfect match
    start_row = None
    if start_pos &gt; 0:
        prev_row = self.at(start_pos - 1)
        if prev_row[&#34;stop&#34;] == start:
            start_pos -= 1
            start_row = prev_row
    if start_row is None:
        start_row = self.at(min(start_pos, len(self) - 1))

    if (
        label == start_row[&#34;label&#34;]
        and start_row[&#34;start&#34;] &lt;= start &lt;= start_row[&#34;stop&#34;]
    ):
        # We hit the right of an existing row
        start_row[&#34;stop&#34;] = start
        # If closed is open/close on left, start_row become the
        # opposite on right:
        start_row[&#34;closed&#34;] = Closed[start_row[&#34;closed&#34;]].set_right(not closed.left)

        if (
            start_row[&#34;start&#34;] == start_row[&#34;stop&#34;]
            and start_row[&#34;closed&#34;] != Closed.BOTH
        ):
            # Ignore star_row
            head = self.head(start_pos)
        else:
            head = Commit.concat(
                self.head(start_pos),
                Commit.one(schema=self.schema, **start_row),
            )
        # when start_row[&#34;start&#34;] == start_row[&#34;stop&#34;],
        # start_row stop and start are both &#34;overshadowed&#34; by
        # new commit

    if head is None:
        head = self.head(start_pos)

    # Truncate stop_pos row
    tail = None
    # stop_pos is the result of a bisect_left, so we have to
    # check the slot on the right that may be perfect match
    stop_row = None
    if stop_pos &lt; len(self):
        next_row = self.at(stop_pos)
        if next_row[&#34;start&#34;] == stop:
            stop_row = next_row
            stop_pos += 1
    if stop_row is None:
        stop_row = self.at(max(0, stop_pos - 1))

    if label == stop_row[&#34;label&#34;] and stop_row[&#34;start&#34;] &lt;= stop &lt;= stop_row[&#34;stop&#34;]:
        # We hit the left of an existing row
        stop_row[&#34;start&#34;] = stop
        # If closed is open/close on right, stop_row become the
        # opposite on left:
        stop_row[&#34;closed&#34;] = Closed[stop_row[&#34;closed&#34;]].set_left(not closed.right)

        if (
            stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;]
            and start_row[&#34;closed&#34;] != Closed.BOTH
        ):
            # Ignore stop_row
            tail = self.tail(stop_pos)
        else:
            tail = Commit.concat(
                Commit.one(schema=self.schema, **stop_row),
                self.tail(stop_pos),
            )
        # when stop_row[&#34;start&#34;] == stop_row[&#34;stop&#34;],
        # stop_row stop and start are both &#34;overshadowed&#34; by
        # new commit
    if tail is None:
        tail = self.tail(stop_pos)
    return Commit.concat(head, inner, tail)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lakota.commit.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>commit, pod, digests, start, stop, closed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Segment:
    def __init__(self, commit, pod, digests, start, stop, closed):
        self.commit = commit
        self.pod = pod
        self.start = start
        self.stop = stop
        self.closed = closed
        self.digest = dict(zip(commit.schema, digests))
        self._frm = None
        self.start_pos = None
        self.stop_pos = None
        self.lock = Lock()

    def __len__(self):
        return len(self.frame)

    def read(self, name, start_pos=None, stop_pos=None):
        # Prime cache
        if not name in self.frame:
            self.frame[name] = self._read(name)
        return self.frame[name][start_pos:stop_pos]

    def _read(self, name):
        dig = self.digest[name]
        # check first if content is not already in commit
        data = self.commit.embedded.get(dig)
        if data is None:
            folder, filename = hashed_path(dig)
            sub_pod = self.pod.cd(folder)
            try:
                data = sub_pod.read(filename)
            except FileNotFoundError:
                for f in sub_pod.ls():
                    # File is in soft-delete mode
                    if f.startswith(filename):
                        data = sub_pod.read(f)
                        break
        arr = self.commit.schema[name].codec.decode(data)
        return arr[self.start_pos : self.stop_pos]

    @property
    def frame(self):
        # Use a Frame instance as container to cache columns
        with self.lock:
            if self._frm is not None:
                return self._frm

            cols = {}
            # with Pool() as pool: # TODO need a smarter pool
            #     for name in self.commit.schema.idx:
            #         pool.submit(lambda: cols.update({name: self._read(name)}))
            for name in self.commit.schema.idx:
                cols[name] = self._read(name)

            frm = Frame(self.commit.schema, cols)
            self.start_pos, self.stop_pos = frm.index_slice(
                self.start, self.stop, closed=self.closed
            )
            self._frm = frm.slice(self.start_pos, self.stop_pos)
            return self._frm</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="lakota.commit.Segment.frame"><code class="name">var <span class="ident">frame</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self):
    # Use a Frame instance as container to cache columns
    with self.lock:
        if self._frm is not None:
            return self._frm

        cols = {}
        # with Pool() as pool: # TODO need a smarter pool
        #     for name in self.commit.schema.idx:
        #         pool.submit(lambda: cols.update({name: self._read(name)}))
        for name in self.commit.schema.idx:
            cols[name] = self._read(name)

        frm = Frame(self.commit.schema, cols)
        self.start_pos, self.stop_pos = frm.index_slice(
            self.start, self.stop, closed=self.closed
        )
        self._frm = frm.slice(self.start_pos, self.stop_pos)
        return self._frm</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.commit.Segment.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, name, start_pos=None, stop_pos=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, name, start_pos=None, stop_pos=None):
    # Prime cache
    if not name in self.frame:
        self.frame[name] = self._read(name)
    return self.frame[name][start_pos:stop_pos]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lakota" href="index.html">lakota</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lakota.commit.Commit" href="#lakota.commit.Commit">Commit</a></code></h4>
<ul class="two-column">
<li><code><a title="lakota.commit.Commit.at" href="#lakota.commit.Commit.at">at</a></code></li>
<li><code><a title="lakota.commit.Commit.closed_codec" href="#lakota.commit.Commit.closed_codec">closed_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.concat" href="#lakota.commit.Commit.concat">concat</a></code></li>
<li><code><a title="lakota.commit.Commit.decode" href="#lakota.commit.Commit.decode">decode</a></code></li>
<li><code><a title="lakota.commit.Commit.delete_labels" href="#lakota.commit.Commit.delete_labels">delete_labels</a></code></li>
<li><code><a title="lakota.commit.Commit.digest_codec" href="#lakota.commit.Commit.digest_codec">digest_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.encode" href="#lakota.commit.Commit.encode">encode</a></code></li>
<li><code><a title="lakota.commit.Commit.head" href="#lakota.commit.Commit.head">head</a></code></li>
<li><code><a title="lakota.commit.Commit.label_codec" href="#lakota.commit.Commit.label_codec">label_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.len_codec" href="#lakota.commit.Commit.len_codec">len_codec</a></code></li>
<li><code><a title="lakota.commit.Commit.mask" href="#lakota.commit.Commit.mask">mask</a></code></li>
<li><code><a title="lakota.commit.Commit.match" href="#lakota.commit.Commit.match">match</a></code></li>
<li><code><a title="lakota.commit.Commit.one" href="#lakota.commit.Commit.one">one</a></code></li>
<li><code><a title="lakota.commit.Commit.rename_label" href="#lakota.commit.Commit.rename_label">rename_label</a></code></li>
<li><code><a title="lakota.commit.Commit.segments" href="#lakota.commit.Commit.segments">segments</a></code></li>
<li><code><a title="lakota.commit.Commit.slice" href="#lakota.commit.Commit.slice">slice</a></code></li>
<li><code><a title="lakota.commit.Commit.split" href="#lakota.commit.Commit.split">split</a></code></li>
<li><code><a title="lakota.commit.Commit.tail" href="#lakota.commit.Commit.tail">tail</a></code></li>
<li><code><a title="lakota.commit.Commit.update" href="#lakota.commit.Commit.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lakota.commit.Segment" href="#lakota.commit.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="lakota.commit.Segment.frame" href="#lakota.commit.Segment.frame">frame</a></code></li>
<li><code><a title="lakota.commit.Segment.read" href="#lakota.commit.Segment.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>