<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lakota.repo API documentation</title>
<meta name="description" content="Create and access collections â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lakota.repo</code></h1>
</header>
<section id="section-intro">
<h2 id="create-and-access-collections">Create and access collections</h2>
<p>Create a <code><a title="lakota.repo.Repo" href="#lakota.repo.Repo">Repo</a></code> instance:</p>
<pre><code class="language-python"># in-memory
repo = Repo()
repo = Repo(&quot;memory://&quot;)
# From a local directory
repo = Repo('some/local/path')
repo = Repo('file://some/local/path')
# From an S3 location
repo = Repo('s3://my_bucket')
# Chain uri with `+` to enable caching
repo = Repo('memory://+s3://my_bucket')
repo = Repo('file:///tmp/local_cache+s3://my_bucket')
</code></pre>
<p>Create one or several collections:</p>
<pre><code class="language-python"># Define schema
schema = Schema(
&quot;&quot;&quot;
timestamp int *
value float
&quot;&quot;&quot;
)
# Create one collections
repo.create_collection(schema, 'my_collection')
# Create a few more
labels = ['one', 'or_more', 'labels']
repo.create_collection(schema, *labels)
</code></pre>
<p>List and instanciate collections</p>
<pre><code class="language-python">print(list(repo.ls())) # Print collections names
# Instanciate a collection
clct = repo.collection('my_collection')
# like pathlib, the `/` operator can be used
clct = repo / 'my_collection'
</code></pre>
<p>See <code><a title="lakota.collection" href="collection.html">lakota.collection</a></code> on how to manipulate collections</p>
<h2 id="garbage-collection">Garbage Collection</h2>
<p>After some times, some series can be overwritten, deleted, squashed or
merged. Sooner or later some pieces of data will get dereferenced,
those can be deleted to recover storage space. It is simply done with
the <code>gc</code> method, which returns the number of deleted files.</p>
<pre><code class="language-python">nb_file_deleted = repo.gc()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
## Create and access collections

Create a `Repo` instance:
```python
# in-memory
repo = Repo()
repo = Repo(&#34;memory://&#34;)
# From a local directory
repo = Repo(&#39;some/local/path&#39;)
repo = Repo(&#39;file://some/local/path&#39;)
# From an S3 location
repo = Repo(&#39;s3://my_bucket&#39;)
# Chain uri with `+` to enable caching
repo = Repo(&#39;memory://+s3://my_bucket&#39;)
repo = Repo(&#39;file:///tmp/local_cache+s3://my_bucket&#39;)
```

Create one or several collections:
```python
# Define schema
schema = Schema(
&#34;&#34;&#34;
timestamp int *
value float
&#34;&#34;&#34;
)
# Create one collections
repo.create_collection(schema, &#39;my_collection&#39;)
# Create a few more
labels = [&#39;one&#39;, &#39;or_more&#39;, &#39;labels&#39;]
repo.create_collection(schema, *labels)
```

List and instanciate collections
```python
print(list(repo.ls())) # Print collections names
# Instanciate a collection
clct = repo.collection(&#39;my_collection&#39;)
# like pathlib, the `/` operator can be used
clct = repo / &#39;my_collection&#39;
```

See `lakota.collection` on how to manipulate collections


## Garbage Collection

After some times, some series can be overwritten, deleted, squashed or
merged. Sooner or later some pieces of data will get dereferenced,
those can be deleted to recover storage space. It is simply done with
the `gc` method, which returns the number of deleted files.

```python
nb_file_deleted = repo.gc()
```
&#39;&#39;&#39;


from .changelog import zero_hash
from .collection import Collection
from .pod import POD
from .schema import Schema
from .utils import Pool, hashed_path, hexdigest, logger

__all__ = [&#39;Repo&#39;]

class Repo:
    &#39;&#39;&#39;
    The `Repo` class manage the organisation of a storage location. It
    provides creation and deletion of collections, synchronization
    with remote repositories and garbage collection.
    &#39;&#39;&#39;
    schema = Schema([&#34;label str*&#34;, &#34;meta O&#34;], kind=&#34;kv&#34;)

    def __init__(self, uri=None, pod=None):
        &#39;&#39;&#39;
        Usually a repo object can be created based on a uri, like this:
        ```python
        repo = Repo(&#39;file://some/dir&#39;)
        ```
        It also accept a `POD` object:
        ```python
        pod = POD.from_uri(&#39;s3://a-bucket-id&#39;)
        repo = Repo(pod=pod)
        ```

        &#39;&#39;&#39;
        pod = pod or POD.from_uri(uri)
        folder, filename = hashed_path(zero_hash)
        self.pod = pod
        path = folder / filename
        # TODO harmonize code between &#39;normal&#39; collection and archive ones
        self.registry = Collection(&#34;registry&#34;, self.schema, path, self)
        self.collection_series = self.registry.series(&#34;collection&#34;)

    def ls(self):
        return [item.label for item in self.search()]

    def __iter__(self):
        return iter(self.ls())

    def push(self, remote, *labels):
        return remote.pull(self, *labels)

    def search(self, label=None, mode=None):
        if label:
            start = stop = (label,)
        else:
            start = stop = None
        if mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            series = self.collection_series
        qr = series[start:stop] @ {&#34;closed&#34;: &#34;both&#34;}

        frm = qr.frame()
        for l in frm[&#34;label&#34;]:
            yield self.collection(l, frm)

    def __truediv__(self, name):
        return self.collection(name)

    def collection(self, label, from_frm=None, mode=None):
        # TODO rename mode into namespace/package/pack ???
        if mode is None:
            series = self.collection_series
        elif mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            raise ValueError(f&#39;Unexpected mode: &#34;{mode}&#34;&#39;)

        if not from_frm:
            from_frm = series.frame()
        frm = from_frm.slice(*from_frm.index_slice([label], [label], closed=&#34;both&#34;))

        if frm.empty:
            return None
        meta = frm[&#34;meta&#34;][-1]
        return self.reify(label, meta)

    def create_collection(self, schema, *labels, raise_if_exists=True, mode=None):
        assert isinstance(
            schema, Schema
        ), &#34;The schema parameter must be an instance of lakota.Schema&#34;
        meta = []
        schema_dump = schema.dump()

        # TODO assert collection does not already exists!

        if mode is None:
            series = self.collection_series
        elif mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            raise ValueError(f&#39;Unexpected mode &#34;{mode}&#34;&#39;)

        for label in labels:
            label = label.strip()
            if len(label) == 0:
                raise ValueError(f&#34;Invalid label&#34;)

            key = label.encode()
            # Use digest to create collection folder (based on mode and label)
            digest = hexdigest(key)
            if mode:
                digest = hexdigest(digest.encode(), mode.encode())
            folder, filename = hashed_path(digest)
            meta.append({&#34;path&#34;: str(folder / filename), &#34;schema&#34;: schema_dump})

        series.write({&#34;label&#34;: labels, &#34;meta&#34;: meta})
        res = [self.reify(l, m) for l, m in zip(labels, meta)]
        if len(labels) == 1:
            return res[0]
        return res

    def reify(self, name, meta):
        schema = Schema.loads(meta[&#34;schema&#34;])
        return Collection(name, schema, meta[&#34;path&#34;], self)

    def archive(self, collection):
        label = collection.label
        archive = self.collection(label, mode=&#34;archive&#34;)
        if archive:
            return archive
        return self.create_collection(collection.schema, label, mode=&#34;archive&#34;)

    def delete(self, *labels):
        to_remove = []
        for l in labels:
            clct = self.collection(l)
            if not clct:
                continue
            to_remove.append(clct.changelog.pod)
        self.collection_series.delete(*labels)
        for pod in to_remove:
            try:
                pod.rm(&#34;.&#34;, recursive=True)
            except FileNotFoundError:
                continue

    def refresh(self):
        self.collection_series.refresh()

    def pull(self, remote, *labels):
        assert isinstance(remote, Repo), &#34;A Repo instance is required&#34;
        # Pull registry
        self.registry.pull(remote.registry)
        # Extract frames
        local_cache = {l.label: l for l in self.search()}
        remote_cache = {r.label: r for r in remote.search()}
        if not labels:
            labels = remote_cache.keys()

        with Pool() as pool:
            for label in labels:
                logger.info(&#34;Sync collection: %s&#34;, label)
                r_clct = remote_cache[label]
                if not label in local_cache:
                    l_clct = self.create_collection(r_clct.schema, label)
                else:
                    l_clct = local_cache[label]
                    if l_clct.schema != r_clct.schema:
                        msg = (
                            f&#39;Unable to sync collection &#34;{label}&#34;,&#39;
                            &#34;incompatible meta-info.&#34;
                        )
                        raise ValueError(msg)
                pool.submit(l_clct.pull, r_clct)

    def merge(self):
        return self.registry.merge()

    def gc(self):
        &#34;&#34;&#34;
        Loop on all series, collect all used digests, and delete obsolete
        ones.
        &#34;&#34;&#34;
        # XXX remove old revisions (anything before a pack commit)

        active_digests = set()
        for mode in (None, &#34;archive&#34;):
            active_digests.update(self.registry.digests())
            for clct in self.search(mode=mode):
                active_digests.update(clct.digests())

        base_folders = self.pod.ls()
        with Pool(8) as pool:
            for folder in base_folders:
                pool.submit(self.gc_folder, folder, active_digests)
        count = sum(pool.results)
        return count

    def gc_folder(self, folder, active_digests):
        count = 0
        pod = self.pod.cd(folder)
        for filename in pod.walk(max_depth=2):
            digest = folder + filename.replace(&#34;/&#34;, &#34;&#34;)
            if digest not in active_digests:
                count += 1
                pod.rm(filename, missing_ok=True)
        return count</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lakota.repo.Repo"><code class="flex name class">
<span>class <span class="ident">Repo</span></span>
<span>(</span><span>uri=None, pod=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="lakota.repo.Repo" href="#lakota.repo.Repo">Repo</a></code> class manage the organisation of a storage location. It
provides creation and deletion of collections, synchronization
with remote repositories and garbage collection.</p>
<p>Usually a repo object can be created based on a uri, like this:</p>
<pre><code class="language-python">repo = Repo('file://some/dir')
</code></pre>
<p>It also accept a <code>POD</code> object:</p>
<pre><code class="language-python">pod = POD.from_uri('s3://a-bucket-id')
repo = Repo(pod=pod)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Repo:
    &#39;&#39;&#39;
    The `Repo` class manage the organisation of a storage location. It
    provides creation and deletion of collections, synchronization
    with remote repositories and garbage collection.
    &#39;&#39;&#39;
    schema = Schema([&#34;label str*&#34;, &#34;meta O&#34;], kind=&#34;kv&#34;)

    def __init__(self, uri=None, pod=None):
        &#39;&#39;&#39;
        Usually a repo object can be created based on a uri, like this:
        ```python
        repo = Repo(&#39;file://some/dir&#39;)
        ```
        It also accept a `POD` object:
        ```python
        pod = POD.from_uri(&#39;s3://a-bucket-id&#39;)
        repo = Repo(pod=pod)
        ```

        &#39;&#39;&#39;
        pod = pod or POD.from_uri(uri)
        folder, filename = hashed_path(zero_hash)
        self.pod = pod
        path = folder / filename
        # TODO harmonize code between &#39;normal&#39; collection and archive ones
        self.registry = Collection(&#34;registry&#34;, self.schema, path, self)
        self.collection_series = self.registry.series(&#34;collection&#34;)

    def ls(self):
        return [item.label for item in self.search()]

    def __iter__(self):
        return iter(self.ls())

    def push(self, remote, *labels):
        return remote.pull(self, *labels)

    def search(self, label=None, mode=None):
        if label:
            start = stop = (label,)
        else:
            start = stop = None
        if mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            series = self.collection_series
        qr = series[start:stop] @ {&#34;closed&#34;: &#34;both&#34;}

        frm = qr.frame()
        for l in frm[&#34;label&#34;]:
            yield self.collection(l, frm)

    def __truediv__(self, name):
        return self.collection(name)

    def collection(self, label, from_frm=None, mode=None):
        # TODO rename mode into namespace/package/pack ???
        if mode is None:
            series = self.collection_series
        elif mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            raise ValueError(f&#39;Unexpected mode: &#34;{mode}&#34;&#39;)

        if not from_frm:
            from_frm = series.frame()
        frm = from_frm.slice(*from_frm.index_slice([label], [label], closed=&#34;both&#34;))

        if frm.empty:
            return None
        meta = frm[&#34;meta&#34;][-1]
        return self.reify(label, meta)

    def create_collection(self, schema, *labels, raise_if_exists=True, mode=None):
        assert isinstance(
            schema, Schema
        ), &#34;The schema parameter must be an instance of lakota.Schema&#34;
        meta = []
        schema_dump = schema.dump()

        # TODO assert collection does not already exists!

        if mode is None:
            series = self.collection_series
        elif mode == &#34;archive&#34;:
            series = self.registry.series(&#34;archive&#34;)
        else:
            raise ValueError(f&#39;Unexpected mode &#34;{mode}&#34;&#39;)

        for label in labels:
            label = label.strip()
            if len(label) == 0:
                raise ValueError(f&#34;Invalid label&#34;)

            key = label.encode()
            # Use digest to create collection folder (based on mode and label)
            digest = hexdigest(key)
            if mode:
                digest = hexdigest(digest.encode(), mode.encode())
            folder, filename = hashed_path(digest)
            meta.append({&#34;path&#34;: str(folder / filename), &#34;schema&#34;: schema_dump})

        series.write({&#34;label&#34;: labels, &#34;meta&#34;: meta})
        res = [self.reify(l, m) for l, m in zip(labels, meta)]
        if len(labels) == 1:
            return res[0]
        return res

    def reify(self, name, meta):
        schema = Schema.loads(meta[&#34;schema&#34;])
        return Collection(name, schema, meta[&#34;path&#34;], self)

    def archive(self, collection):
        label = collection.label
        archive = self.collection(label, mode=&#34;archive&#34;)
        if archive:
            return archive
        return self.create_collection(collection.schema, label, mode=&#34;archive&#34;)

    def delete(self, *labels):
        to_remove = []
        for l in labels:
            clct = self.collection(l)
            if not clct:
                continue
            to_remove.append(clct.changelog.pod)
        self.collection_series.delete(*labels)
        for pod in to_remove:
            try:
                pod.rm(&#34;.&#34;, recursive=True)
            except FileNotFoundError:
                continue

    def refresh(self):
        self.collection_series.refresh()

    def pull(self, remote, *labels):
        assert isinstance(remote, Repo), &#34;A Repo instance is required&#34;
        # Pull registry
        self.registry.pull(remote.registry)
        # Extract frames
        local_cache = {l.label: l for l in self.search()}
        remote_cache = {r.label: r for r in remote.search()}
        if not labels:
            labels = remote_cache.keys()

        with Pool() as pool:
            for label in labels:
                logger.info(&#34;Sync collection: %s&#34;, label)
                r_clct = remote_cache[label]
                if not label in local_cache:
                    l_clct = self.create_collection(r_clct.schema, label)
                else:
                    l_clct = local_cache[label]
                    if l_clct.schema != r_clct.schema:
                        msg = (
                            f&#39;Unable to sync collection &#34;{label}&#34;,&#39;
                            &#34;incompatible meta-info.&#34;
                        )
                        raise ValueError(msg)
                pool.submit(l_clct.pull, r_clct)

    def merge(self):
        return self.registry.merge()

    def gc(self):
        &#34;&#34;&#34;
        Loop on all series, collect all used digests, and delete obsolete
        ones.
        &#34;&#34;&#34;
        # XXX remove old revisions (anything before a pack commit)

        active_digests = set()
        for mode in (None, &#34;archive&#34;):
            active_digests.update(self.registry.digests())
            for clct in self.search(mode=mode):
                active_digests.update(clct.digests())

        base_folders = self.pod.ls()
        with Pool(8) as pool:
            for folder in base_folders:
                pool.submit(self.gc_folder, folder, active_digests)
        count = sum(pool.results)
        return count

    def gc_folder(self, folder, active_digests):
        count = 0
        pod = self.pod.cd(folder)
        for filename in pod.walk(max_depth=2):
            digest = folder + filename.replace(&#34;/&#34;, &#34;&#34;)
            if digest not in active_digests:
                count += 1
                pod.rm(filename, missing_ok=True)
        return count</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lakota.repo.Repo.schema"><code class="name">var <span class="ident">schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lakota.repo.Repo.archive"><code class="name flex">
<span>def <span class="ident">archive</span></span>(<span>self, collection)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def archive(self, collection):
    label = collection.label
    archive = self.collection(label, mode=&#34;archive&#34;)
    if archive:
        return archive
    return self.create_collection(collection.schema, label, mode=&#34;archive&#34;)</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.collection"><code class="name flex">
<span>def <span class="ident">collection</span></span>(<span>self, label, from_frm=None, mode=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collection(self, label, from_frm=None, mode=None):
    # TODO rename mode into namespace/package/pack ???
    if mode is None:
        series = self.collection_series
    elif mode == &#34;archive&#34;:
        series = self.registry.series(&#34;archive&#34;)
    else:
        raise ValueError(f&#39;Unexpected mode: &#34;{mode}&#34;&#39;)

    if not from_frm:
        from_frm = series.frame()
    frm = from_frm.slice(*from_frm.index_slice([label], [label], closed=&#34;both&#34;))

    if frm.empty:
        return None
    meta = frm[&#34;meta&#34;][-1]
    return self.reify(label, meta)</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.create_collection"><code class="name flex">
<span>def <span class="ident">create_collection</span></span>(<span>self, schema, *labels, raise_if_exists=True, mode=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_collection(self, schema, *labels, raise_if_exists=True, mode=None):
    assert isinstance(
        schema, Schema
    ), &#34;The schema parameter must be an instance of lakota.Schema&#34;
    meta = []
    schema_dump = schema.dump()

    # TODO assert collection does not already exists!

    if mode is None:
        series = self.collection_series
    elif mode == &#34;archive&#34;:
        series = self.registry.series(&#34;archive&#34;)
    else:
        raise ValueError(f&#39;Unexpected mode &#34;{mode}&#34;&#39;)

    for label in labels:
        label = label.strip()
        if len(label) == 0:
            raise ValueError(f&#34;Invalid label&#34;)

        key = label.encode()
        # Use digest to create collection folder (based on mode and label)
        digest = hexdigest(key)
        if mode:
            digest = hexdigest(digest.encode(), mode.encode())
        folder, filename = hashed_path(digest)
        meta.append({&#34;path&#34;: str(folder / filename), &#34;schema&#34;: schema_dump})

    series.write({&#34;label&#34;: labels, &#34;meta&#34;: meta})
    res = [self.reify(l, m) for l, m in zip(labels, meta)]
    if len(labels) == 1:
        return res[0]
    return res</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, *labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, *labels):
    to_remove = []
    for l in labels:
        clct = self.collection(l)
        if not clct:
            continue
        to_remove.append(clct.changelog.pod)
    self.collection_series.delete(*labels)
    for pod in to_remove:
        try:
            pod.rm(&#34;.&#34;, recursive=True)
        except FileNotFoundError:
            continue</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.gc"><code class="name flex">
<span>def <span class="ident">gc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loop on all series, collect all used digests, and delete obsolete
ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gc(self):
    &#34;&#34;&#34;
    Loop on all series, collect all used digests, and delete obsolete
    ones.
    &#34;&#34;&#34;
    # XXX remove old revisions (anything before a pack commit)

    active_digests = set()
    for mode in (None, &#34;archive&#34;):
        active_digests.update(self.registry.digests())
        for clct in self.search(mode=mode):
            active_digests.update(clct.digests())

    base_folders = self.pod.ls()
    with Pool(8) as pool:
        for folder in base_folders:
            pool.submit(self.gc_folder, folder, active_digests)
    count = sum(pool.results)
    return count</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.gc_folder"><code class="name flex">
<span>def <span class="ident">gc_folder</span></span>(<span>self, folder, active_digests)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gc_folder(self, folder, active_digests):
    count = 0
    pod = self.pod.cd(folder)
    for filename in pod.walk(max_depth=2):
        digest = folder + filename.replace(&#34;/&#34;, &#34;&#34;)
        if digest not in active_digests:
            count += 1
            pod.rm(filename, missing_ok=True)
    return count</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ls(self):
    return [item.label for item in self.search()]</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self):
    return self.registry.merge()</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.pull"><code class="name flex">
<span>def <span class="ident">pull</span></span>(<span>self, remote, *labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull(self, remote, *labels):
    assert isinstance(remote, Repo), &#34;A Repo instance is required&#34;
    # Pull registry
    self.registry.pull(remote.registry)
    # Extract frames
    local_cache = {l.label: l for l in self.search()}
    remote_cache = {r.label: r for r in remote.search()}
    if not labels:
        labels = remote_cache.keys()

    with Pool() as pool:
        for label in labels:
            logger.info(&#34;Sync collection: %s&#34;, label)
            r_clct = remote_cache[label]
            if not label in local_cache:
                l_clct = self.create_collection(r_clct.schema, label)
            else:
                l_clct = local_cache[label]
                if l_clct.schema != r_clct.schema:
                    msg = (
                        f&#39;Unable to sync collection &#34;{label}&#34;,&#39;
                        &#34;incompatible meta-info.&#34;
                    )
                    raise ValueError(msg)
            pool.submit(l_clct.pull, r_clct)</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, remote, *labels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, remote, *labels):
    return remote.pull(self, *labels)</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    self.collection_series.refresh()</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.reify"><code class="name flex">
<span>def <span class="ident">reify</span></span>(<span>self, name, meta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reify(self, name, meta):
    schema = Schema.loads(meta[&#34;schema&#34;])
    return Collection(name, schema, meta[&#34;path&#34;], self)</code></pre>
</details>
</dd>
<dt id="lakota.repo.Repo.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, label=None, mode=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, label=None, mode=None):
    if label:
        start = stop = (label,)
    else:
        start = stop = None
    if mode == &#34;archive&#34;:
        series = self.registry.series(&#34;archive&#34;)
    else:
        series = self.collection_series
    qr = series[start:stop] @ {&#34;closed&#34;: &#34;both&#34;}

    frm = qr.frame()
    for l in frm[&#34;label&#34;]:
        yield self.collection(l, frm)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#create-and-access-collections">Create and access collections</a></li>
<li><a href="#garbage-collection">Garbage Collection</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lakota" href="index.html">lakota</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lakota.repo.Repo" href="#lakota.repo.Repo">Repo</a></code></h4>
<ul class="two-column">
<li><code><a title="lakota.repo.Repo.archive" href="#lakota.repo.Repo.archive">archive</a></code></li>
<li><code><a title="lakota.repo.Repo.collection" href="#lakota.repo.Repo.collection">collection</a></code></li>
<li><code><a title="lakota.repo.Repo.create_collection" href="#lakota.repo.Repo.create_collection">create_collection</a></code></li>
<li><code><a title="lakota.repo.Repo.delete" href="#lakota.repo.Repo.delete">delete</a></code></li>
<li><code><a title="lakota.repo.Repo.gc" href="#lakota.repo.Repo.gc">gc</a></code></li>
<li><code><a title="lakota.repo.Repo.gc_folder" href="#lakota.repo.Repo.gc_folder">gc_folder</a></code></li>
<li><code><a title="lakota.repo.Repo.ls" href="#lakota.repo.Repo.ls">ls</a></code></li>
<li><code><a title="lakota.repo.Repo.merge" href="#lakota.repo.Repo.merge">merge</a></code></li>
<li><code><a title="lakota.repo.Repo.pull" href="#lakota.repo.Repo.pull">pull</a></code></li>
<li><code><a title="lakota.repo.Repo.push" href="#lakota.repo.Repo.push">push</a></code></li>
<li><code><a title="lakota.repo.Repo.refresh" href="#lakota.repo.Repo.refresh">refresh</a></code></li>
<li><code><a title="lakota.repo.Repo.reify" href="#lakota.repo.Repo.reify">reify</a></code></li>
<li><code><a title="lakota.repo.Repo.schema" href="#lakota.repo.Repo.schema">schema</a></code></li>
<li><code><a title="lakota.repo.Repo.search" href="#lakota.repo.Repo.search">search</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>